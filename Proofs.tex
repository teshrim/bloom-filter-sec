\section{Proofs}
\tsnote{Jon: ignore these for now.  This is Animesh's workspace.}
\begin{theorem}\label{thm}
Fix $k, m, n > 0$ and define a hash-based filter as in section \ref{sec:hbf}, except the hash functions are defined by $h_j(x) = \left( f_{K_0}(x) + j\cdot g_{K_1}(x)\right) \bmod m$. Let $Func(m,m)$ be the set of all functions $\rho \colon \calK \times \bits^m \sends \bits^m$. Let $B_1, B_2$ be 2 adversaries attacking the PRF advantage of $F \colon \calK \times \bits^m \sends \bits^m$ and $A$ be another adversary attacking the false positive game of hash-based filters, then 

\begin{equation}
\AdvFPSecHash{B}{A} = \abs{ \AdvPRF{F}{B_2} - \AdvPRF{F}{B_1}} \pm q \cdot \epsilon
\end{equation}
Note: Here, $q$ is the number of queries made to the $\QryOracle$ oracle and $\epsilon$ is the false positive error in the double hashing scheme given by Kirsch and Mitzenmacher. $\epsilon \rightarrow 0$, if $m/n \rightarrow \infty$ and/or $k \rightarrow \infty$ \cite{xxx}
\end{theorem}

\begin{proof}
The proof of the theorem will use a game playing argument as shown in Fig. \ref{fig:Game}. $\game{0}(A)$ exactly simulates $\ExpFPSecHash{B}{A}$ with hash functions $h_j(x) = \left( f_{K_0}(x) + j\cdot g_{K_1}(x)\right) \bmod m$. So,
\begin{equation}
\AdvFPSecHash{B}{A} = \Prob{\game{0}(A)=1}\label{eq:0}
\end{equation}
 $\game{1}(A)$ and $\game{2}(A)$ attack 2 different filters, $B_1$ and $B_2$, with hash functions 
\begin{eqnarray*}
h_j(x) &=& ( f_{K_0}(x) + j\cdot \rho_2(x)) \bmod m\\
h_j(x) &=& ( \rho_1(x) + j \cdot \rho_2(x)) \bmod m 
\end{eqnarray*}
Here, $\rho_1$ and $\rho_2$ are random functions sampled from $Func(m,m)$. Let adversary $B_1, B_2$ simulate $\game{1}(A)$ and $\game{2}(A)$ respectively as shown in Fig. \ref{fig:BGame1}.

\par{In a classical Bloom filter, adversary $A^{'}$ is non-adaptive, i.e., for some fixed $x \notin S$, $A^{'}$ targets the false-positive error conditioned on randomness of hash functions. But in the $\ExpFPSecHash{B}{A}$ game, $A$ is adaptive, as it can adapt its queries as well as its output based on response of $\QryOracle$ oracle. Let $A$ makes $q$ queries $x_1, x_2, ..., x_q$ to the $\QryOracle$ oracle. $\game{3}(A)$ simulates $fp-error$ game of $A^{'}$ as shown in Fig. \ref{fig:Game}.}

%\caption{Game playing argument}\label{fig:Game}
\begin{figure}[h]
\fpage{.95}{
\hpagessd{.5}{.5}
{
\underline{\game{0}(A)}\\
$K_1, K_2 \getsr \calK$\\
$S \getsr \distr{U}{n}$\\
$M \getsr \Rep^{\HashOracle(\cdot, \cdot)}(S)$\\
$x \getsr A^{\QryOracle(\cdot)}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle(\cdot, \cdot)}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0\\\\
%
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle(\cdot, \cdot)}(M,x)$\\\\
%
\oracle{$\HashOracle(i,x)$}\\
$h_i(x) = F_{K_1}(x)+i \cdot F_{K_2}(x)$\\
Ret $h_i(x)$
}
{
\underline{\game{1}(A)}\\
$K_1 \getsr \calK$\\
$\rho \getsr Func(m,m)$\\
$S \getsr \distr{U}{n}$\\
$M \getsr \Rep^{\HashOracle(\cdot, \cdot)}(S)$\\
$x \getsr A^{\QryOracle(\cdot)}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle(\cdot, \cdot)}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0\\\\
%
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle(\cdot, \cdot)}(M,x)$\\\\
%
\oracle{$\HashOracle(i,x)$}\\
$h_i(x) = F_{K_1}(x)+i \cdot \rho(x)$\\
Ret $h_i(x)$
}
{
\underline{\game{2}(A)}\\
$\rho_1,\rho_2 \getsr Func(m,m)$\\
$S \getsr \distr{U}{n}$\\
$M \getsr \Rep^{\HashOracle(\cdot, \cdot)}(S)$\\
$x \getsr A^{\QryOracle(\cdot)}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle(\cdot, \cdot)}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0\\\\
%
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle(\cdot, \cdot)}(M,x)$\\\\
%
\oracle{$\HashOracle(i,x)$}\\
$h_i(x) = \rho_1(x)+i \cdot \rho_2(x)$\\
Ret $h_i(x)$
}
{
\underline{$\game{3}(A)$}\\
$t \getsr [q]$, where $[q] = {0,1, \cdots, q-1}$\\
$count = 0$ \\%count will be used to keep track of queries made to $\QryOracle$\\
$win \gets false$\\
$\rho_1,\rho_2 \getsr Func(m,m)$\\
$S \getsr \distr{U}{n}$\\
$M \getsr \Rep^{\HashOracle(\cdot, \cdot)}(S)$\\
$x \getsr A^{\QryOracle(\cdot)}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle(\cdot, \cdot)}(M,x)=1$ then\\
$\nudge $ Ret 1\\
Ret 0\\\\
%
\oracle{$\QryOracle(x)$}\\
$count=count +1$\\
if $(count == t)$\\
$\nudge win = true$\\
$\nudge \mathrm{Ret} \nudge \Qry^{\HashOracle(\cdot, \cdot)}(M,x)$\\
else \\
$\nudge \mathrm{Ret}\nudge 0$\\\\
%
\oracle{$\HashOracle(i,x)$}\\
$h_i(x) = \rho_1(x)+i \cdot \rho_2(x)$\\
Ret $h_i(x)$
}
}
\caption{Game playing argument}\label{fig:Game}
\end{figure}

%\caption{Adversary $B_1, B_2$ simulating $\game{1}(A)$ and $\game{2}(A)$ respectively}\label{fig:BGame1}
\begin{figure}[h]
\centering
\fpage{0.9}{
\hpagessl{0.5}{0.5}
{
$\experimentv{Adversary \nudge B_1^{\calO}:}$\\
$K_1 \getsr \calK $\\
$S \getsr \distr{U}{n}$\\
$M \getsr \Rep^{\HashOracle(\cdot, \cdot)}(S)$\\
When $A$ asks $\QryOracle(x)$:\\
$\nudge$ Ret $\Qry^{\HashOracle(\cdot, \cdot)}(M,x)$\\
When $A$ halts with output $x^{'}$: \\
$\nudge$if $x^{'} \not\in S \wedge \Qry^{\HashOracle(\cdot, \cdot)}(M,x^{'})=1$ then\\
$\nudge$ $\nudge$ Ret 1\\
$\nudge$ Ret 0\\\\
\oracle{$\HashOracle(i,x)$}\\
$ \mathrm{Ret} \nudge F_{K_1}(x) + i\cdot \calO(x)$\\
}
{
$\experimentv{Adversary \nudge B_2^{\calO}:}$\\
%$d \getsr \bits $\\
$\rho_2 \getsr Func(m,m)$\\
$S \getsr \distr{U}{n}$\\
$M \getsr \Rep^{\HashOracle(\cdot, \cdot)}(S)$\\
When $A$ asks $\QryOracle(x)$:\\
$\nudge$ Ret $\Qry^{\HashOracle(\cdot, \cdot)}(M,x)$\\
When $A$ halts with output $x^{'}$: \\
$\nudge$if $x^{'} \not\in S \wedge \Qry^{\HashOracle(\cdot, \cdot)}(M,x^{'})=1$ then\\
$\nudge$$\nudge$ Ret 1\\
$\nudge$Ret 0\\\\
\oracle{$\HashOracle(i,x)$}\\
%if $d=0$\\
$\mathrm{Ret} \nudge \calO(x) + i\cdot \rho_2(x)$
}
}
\caption{Adversary $B_1, B_2$ simulating $\game{1}(A)$ and $\game{2}(A)$ respectively}\label{fig:BGame1}
\end{figure}

\begin{eqnarray}
\nonumber \Prob{\ExpPRF{F}{B_1} = 1} &=& .5\Prob{\ExpPRF{F}{B_1}=1|b=0} + .5\Prob{\ExpPRF{F}{B_1} = 1|b=1}\\
\nonumber (2\Prob{\ExpPRF{F}{B_1} = 1} - 1) + 1 &=& \Prob{\game{1}(A)=1} + \Prob{\game{0}(A)=1}\\
 1 + \AdvPRF{F}{B_1} &=& \Prob{\game{1}(A)=1} + \Prob{\game{0}(A)=1} \label{eq:1}\\
\nonumber& &\\
\nonumber \Prob{\ExpPRF{F}{B_2} = 1} &=& .5\Prob{\ExpPRF{F}{B_2}=1|b=0} + .5\Prob{\ExpPRF{F}{B_2} = 1|b=1}\\
\nonumber (2\Prob{\ExpPRF{F}{B_2} = 1} - 1) + 1 &=& \Prob{\game{2}(A)=1} + \Prob{\game{1}(A)=1}\\
 1 + \AdvPRF{F}{B_2} &=& \Prob{\game{2}(A)=1} + \Prob{\game{1}(A)=1}\label{eq:2}
\end{eqnarray}

Subtracting \ref{eq:1} from \ref{eq:2}, we have
\begin{eqnarray}
\abs{ \AdvPRF{F}{B_2} - \AdvPRF{F}{B_1}} &= \abs{\Prob{\game{2}(A)=1} - \Prob{\game{0}(A)=1}}\label{eq:2a}
\end{eqnarray}

In $\game{3}(A)$, assume, without loss of generality that $A$ halts with output $x$ immediately, if it asks $x$ to $\QryOracle$ and $\QryOracle$ returns $1$. Thus, all queries to $\QryOracle$ return 0 until the first one. Hence,

\begin{equation}
\Prob{\game{2}(A)=1} \leq q \cdot \Prob{\game{3}(A)=1} = q \cdot \Prob{\game{3}(A)=1|win=true}\label{eq:3}
\end{equation}

In Fig. \ref{AGame3}, adversary $A^{'}$ simulates $\game{3}(A)$. Since, adversary $A^{'}$ exactly simulates $\game{3}(A)$ conditioned on $win = true$, 
\begin{eqnarray}
\nonumber \Prob{\game{3}(A)|win=true} &=& \Prob{A^{'} \mathrm{outputs \nudge FP}}\\
& \leq & \epsilon, \nudge \mathrm{where} \nudge \epsilon = (1-e^{-kn/m})^k\label{eq:4}
\end{eqnarray}

%\caption{Adversary $A^{'}$ simulating $\game{3}(A)$} \label{AGame3}
\begin{figure}
\centering
\fpage{0.4}{
$\experimentv{Adversary \nudge A^{{'}\HashOracle(\cdot, \cdot)}:}$\\
$t \getsr [q]$, where $[q] = {0,1, \cdots, q-1}$\\
$count = 0$\\
$\rho_1,\rho_2 \getsr Func(m,m)$\\
$S \getsr \distr{U}{n}$\\
$M \getsr \Rep^{\HashOracle(\cdot, \cdot)}(S)$\\
When $A$ asks $\QryOracle(x)$:\\
$\nudge cnt = cnt + 1$\\
$\nudge \mathrm{if} \nudge count == t$\\
$\nudge r \gets \Qry^{\HashOracle(\cdot, \cdot)}(M,x)$\\
if $r==1$\\
$\nudge$ $A$ halts with output $x$\\
$\nudge$ Ret 1\\
else\\
$\nudge$ $A$ outputs NULL\\
$\nudge$ Ret 0\\\\
%
\oracle{$\HashOracle(i,x)$}\\
$h_i(x) = \rho_1(x)+i \cdot \rho_2(x)$\\
Ret $h_i(x)$
}
\caption{Adversary $A^{'}$ simulating $\game{3}(A)$} \label{AGame3}
\end{figure}	

From eqn. \ref{eq:0}, \ref{eq:2a}, \ref{eq:3} and \ref{eq:4}: \\
\begin{eqnarray}
\nonumber \abs{ \AdvPRF{F}{B_2} - \AdvPRF{F}{B_1}} &=& \abs{q \cdot \epsilon - \Prob{\ExpFPSecHash{B}{A}=1}}\\
\AdvFPSecHash{B}{A} &=& \abs{ \AdvPRF{F}{B_2} - \AdvPRF{F}{B_1}} \pm q \cdot \epsilon
\end{eqnarray}
\end{proof}
