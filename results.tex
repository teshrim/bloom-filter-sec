\section{Case Studies}\label{sec:case_studies}
Here we explore various set-membership data structures that have been proposed
in the literature with respect to our definitions.

%%%%%%%%%%%%%%%%% CLASSICAL BLOOM FILTER IN ROM %%%%%%%%%%%%%%%%%%%%

\begin{figure}[tp]
\centering
\hfpagess{.4}{.4}
{
\algorithmv{$\Rep^H(S)$}\\
$M \gets 0^m$\\
for $x \in S$\\
\nudge for $j \in \{1,2,\ldots,k\}$\\
\nudge\nudge $h_j \gets H(j,x)$\\
\nudge\nudge $M[h_j] \gets 1$\\
$\pubaux \gets M$, $\privaux \gets \emptystring$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry^H(\pubaux,\privaux,q_x)$}\\
$M\gets\pubaux$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets H(j,x)$\\
\nudge if $M[h_j] \neq 1$ then Return 0\\
Return 1
}
{
\algorithmv{$\Rep(S)$}\\
$M \gets 0^m$; $K \getsr \calK$\\
for $x \in S$\\
\nudge for $j \in \{1,2,\ldots,k\}$\\
\nudge\nudge $h_j \gets F_{K}(\langle j,x \rangle) $\\
\nudge\nudge $M[h_j] \gets 1$\\
$\pubaux \gets M$, $\privaux \gets \langle K \rangle$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry(\pubaux,\privaux,q_x)$}\\
$M\gets\pubaux$, $K \gets \privaux$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets F_{K}(\langle j,x \rangle) $\\
\nudge if $M[h_j] \neq 1$ then Return 0\\
Return 1 } \caption{{\bf Left:} $\Rep$ and $\Qry$ algorithms for the
classical Bloom
  filter $\setprim_{\mathrm{Bloom}}$ in the ROM for a hash function $H\colon \mathbb{N} \times
  \elts \to [m]$, where $|S| \leq n$. \jnote{Both should abort if $|S|>n$.}
  {\bf Right:} $\Rep$ and $\Qry$
  algorithms for the domain-separated PRF data structure
  $\setprim_{\mathrm{ds}}$, using function family $F \colon
  \calK \times \elts \to [m]$.  Both constructions have query set $\calQ=\{q_x\colon
  \univ \to \bits\}$ where $q_x(S)=1 \Leftrightarrow x \in S$.  }
\label{fig:bf-and-ds}
\end{figure}

\subsection{Classical Bloom Filter in the Random-Oracle Model}
Fix $k,m,n \geq 0$ and a universe $\elts$.  Then the classical Bloom
filter set-membership data structure $\setprim_{\mathrm{Bloom}}=
(\Rep, \Qry)$ over~$\elts$ is defined as in
Figure~\ref{fig:bf-and-ds} (left side) for sets $S \subseteq \elts$
of size at most $|S|\leq n$. \jnote{This should really be
parameterized everywhere, e.g., as
$\setprim_{\mathrm{Bloom}}^{k,m,n}$.} We
define~$\setprim_{\mathrm{Bloom}}$ in the random-oracle model (ROM),
as the traditional analysis of correctness (as a function of
$n,k,m$) is done in this model.\footnote{The standard-model version
would have $\Rep$ choose $H_1,\ldots,H_k$ from some function family,
compute $h_j$ using these, and place their description in
$\pubaux$.}

\heading{Correctness. } We prove that the Bloom filter meets our
correctness notion in the ROM.  Again, we stress that this
correctness is with respect to adaptive adversaries, aiming to find
$r \geq 1$ errors (in this case, false-positives).

\jnote{We should state the bound in the theorem in terms of resource
bounds , rather than in terms of a fixed adversary~$A$ (i.e., bound
$\Pi_{\mathrm{Bloom},r}(t,q_T, q_H)$ not
$\Pi_{\mathrm{Bloom},r}(A)$---note we need to define the former in
the ROM in Section~3). Same goes for all theorems.}

\begin{theorem}\label{thm3}\label{thm:bf-correctness}
Fix $k,m,n,r>0$ and~$\elts$, and let $\setprim_{\mathrm{Bloom}}=
(\Rep, \Qry)$ be the classical Bloom filter (set-membership) data
structure over~$\elts$. For any adversary~$A$ that makes a total
of~$q_T$ queries to the $\Test$ oracle, $q_R$ queries to the random
oracle, and has time-complexity~$O(t)$,
\[
\AdvCorrect{\setprim_{\mathrm{Bloom}},r}{A} \leq  {\dbinom{q_T + q_H}{r}} \left( (1-e^{-kn/m})^k + O(1/n) \right)^r\,.
\]
\end{theorem}
Note that Kirsch and Mitzenmacher~\cite{kirsch2006less} show that
the ($r=1$, zero-query) error-probability
for~$\setprim_\mathrm{Bloom}$ is %always within $O(1/n)$ of
$(1-e^{-kn/m})^k+O(1/n)$, though the asymptotic rate of convergence
is faster than~$1/n$.
The multiplicative %(``hybrid'')
term is due to moving from the zero-query to the adaptive setting.
Also note that $\binom{q_T+q_H}{r} \leq (eq/r)^r$ (letting
$q=q_T+q_H$), in which case the bound becomes
\[\left(eq/r \cdot (1-e^{-kn/m})^k + O(q/rn) \right)^r.\]
Loosely, and ignoring the low-order term, this is the bound expected
by viewing the attacker as trying to find an error in each of~$r$
independent``rounds,'' each round consisting of~$q/r$ attempts.
\jnote{I didn't find the last two sentences helpful.}
\input{BF_correctness}

\heading{Privacy. } We observe that, intuitively, the classical
Bloom filter does not meet our simulation-based privacy notion
except in trivial cases (e.g., if the leakage function reveals the
entire set, the false-positive rate is~1, or the attacker makes no
$H$-queries). This is because the attacker knows the set~$S$; as
long as the attacker can compute~$H$ (as it can in the ROM), it can
simply check that the $\pubaux$ it receives is consistent with~$S$.
%\tsnote{I'm still not completely comfortable with this.  It isn't explicit in our SS notion, but I assume that~$A$ is stateful and so knows~$S$ in its second stage?  If so, I wonder if the classic BF in the ROM would be secure relative to a weaker notion (but still stronger than OW) in which the second stage does not know~$S$?  This seems likely to me.}
We note that this will be true for \emph{any} data structure for
which $\privaux$ is empty, since in that case $\pubaux$ alone
suffices to evaluate $\Qry(\pubaux,\privaux,\cdot)$. \jnote{In the
ROM the attack requires that the attacker can query the ROM
sufficiently many times.}

On the other hand, we can show that the classical Bloom filter does
meet our notion of one-wayness in the~ROM:

\begin{theorem}%[{\rm OW-privacy of classic BF in the ROM}]
%\label{thm3}
\label{thm:bf-ow} Fix $k,m,n>0$ and~$\elts$, and let
$\setprim_{\mathrm{Bloom}}= (\Rep, \Qry)$ be the classical Bloom
filter data structure over~$\elts$. Let $\distr{}{}$ be a
distribution over subsets of $\elts$ of size at most~$n$, and let
$\mu = H_\infty(\distr{}{})$. Then for any adversary~$A$ that makes
at most $q_H$~queries to~$H$,
\[
\AdvPrivOW{\setprim_{\mathrm{Bloom}},\distr{}{}}{A} \leq  \frac{(kq_H n+n)}{2^{\mu}}\;.
\]
\end{theorem}
\jnote{I don't see how you get the above bound. A gross upper bound
is obtained by saying that the attacker wins if it ever makes a
single query $H(\star, x)$ with $x \in S$. The probability of that
is $q_H/2^\mu$, which is better than $kq_Hn/2^\mu$.} The
straightforward proof will appear in the full version. Roughly, the
$kqn/2^{\mu}$ term \jnote{Revisit later.} arises from the event that
random-oracle queries reveal an element of~$S$, and the $n/2^\mu$
term represents the probability that the attacker simply guesses an
element of~$S$.

%%%%%%%%%%%%%%%%% DOMAIN-SEPARATED PRF %%%%%%%%%%%%%%%%%%%%

\subsection{A Secret-Key Variant of the Bloom Filter}
Next we consider a natural, secret-key variant of the classical
Bloom filter where the (private) hash functions are instantiated via
$H(j,x)=F_K(\langle j,x\rangle)$, where $F$ is a pseudorandom
function (PRF), using domain separation to turn a PRF into,
effectively, multiple (independent) random functions. (Refer to the
right side of Figure~\ref{fig:bf-and-ds}.) We call this the
\emph{domain-separated PRF data structure}.

\jnote{Maybe just call it ``pseudorandom hash''?}

%\heading{Construction of PRF with domain separation.}
\heading{Correctness. } As in Theorem~\ref{thm3}, the following says
(informally) that if~$F$ is a PRF, then the domain-separated PRF
construction enjoys correct against adaptive adversaries.

% \tsnote{Not really appropriate to say this next thing; I'll add a new section that addresses bigram DS-PRF hash.}
% We note that Neidermayer et
% al. in~\cite{xxx} suggest replacing the linear-PRF hash functions in
% the previous construction with independently keyed PRFs as a way to
% thwart their attacks.  The construction we consider now achieves the
% same end, albeit via explict domain separation rather than separate
% keys.

\jnote{As with the classical BF, this should always be
parameterized, e.g., as $\setprim_{\mathrm{ds}}^{k,m,n}(F)$.}

\begin{theorem}%[{\rm Correctness of DS-PRF}]
\label{thm2}\label{thm:ds-correctness} Fix $k,m,n,r>0$ and~$\elts$,
and let $\setprim_{\mathrm{ds}}= (\Rep, \Qry)$ be the
domain-separated PRF data structure over $\elts$. Then
\[
\AdvCorrect{\setprim_{\mathrm{ds}},r}{t, q_T} \leq  \AdvPRF{F}{O(t+q_T m), q_T}  + {\dbinom{q_T}{r}} \cdot \left( (1-e^{-kn/m})^k + O(1/n) \right)^r\,.
\]
\end{theorem}
\jnote{I don't think we ever define $\AdvPRF{F}{q, t}$.}

%We note that Kirsch and Mitzenmacher~\cite{kirsch2006less} show
%that the ($r=1$, zero-query) error-probability for~$\setprim_\mathrm{ds}$ is
%always within $O(1/n)$ of $(1-e^{-kn/m})^k$, although the asymptotic
%rate of convergence is faster than~$1/n$.   As before, the multiplicative term $\binom{q}{r}$ arises when switching from the adaptive to zero-query settings.
\jnote{The proof of this theorem should be ``morally the same'' as
the proof of Theorem~\ref{thm3} (unless I am missing some
subtlety?). So I think we should omit this proof altogether. If not,
then it should follow the same structure as the proof of
Theorem~\ref{thm3} or else the reader is likely to be confused (as I
was).}

\input{ds-correctness}


\heading{Privacy. } In contrast to the case of classical Bloom
filters (with public hash functions), the domain-separated PRF data
structure achieves our simulation-based notion of privacy. Indeed,
this follows directly from Theorem~\ref{thm:priv-ss}.

\begin{theorem}%[\rm{SS-privacy of DS PRF}]
\label{thm:ds-ss} Fix $k,m,n>0$ and~$\elts$, and let
$\setprim_{\mathrm{ds}}= (\Rep, \Qry)$ be the domain-separated PRF
data structure over~$\elts$.  Let $\leak(S)=|S|$. Then \jnote{Need
to rewrite theorem statement.}
\[
\AdvPrivSS{\setprim_{\mathrm{ds}},\leak}{A,\Sim} \leq
\AdvPRF{F}{B}\,.
\]
%(Both~$B$ and~$\Sim$ are explicitly constructed in the proof of this theorem.)
\end{theorem}
\begin{proof}
Let $\ell(n) = kn$, let $\Rep_1$ be the algorithm that, on input a
set $S=\{x_1,\ldots,x_n\}$, outputs $\{\langle i,x_j \rangle\}_{i\in
{k}, j \in [n]}$, and let $\Rep_2$ be the algorithm that, on input
$n,y_1, \ldots, y_{\ell(n)}$, initializes an $m$-bit array $M$ to~0
and then sets $M[y_i] \gets 1$ for $i \in [\ell(n)]$. One can easily
verify that $(\Rep_1, \Rep_2, \ell, F)$ is a factoring
of~$\Pi_{\mathrm{ds}}$. Applying Theorem~\ref{thm:priv-ss} yields
the claimed result. \hfill\qed
\end{proof}


%%%%%%%%%%%%%%%%% LINEAR-PRF %%%%%%%%%%%%%%%%%%%%
\begin{figure}[tp]
\centering
\hfpagess{.45}{.45}
{
\algorithmv{$\Rep(S)$}\\
$M \gets 0^m$; $K \getsr \calK$\\
for $x \in S$\\
%\jnote{Fix}\tsnote{Fix what?}\\
\nudge $f_1 \gets F_{K}(\langle 1,x \rangle)$, $f_2 \gets F_{K}(\langle 2,x \rangle)$\\
\nudge for $j \in \{1,2,\ldots,k\}$\\
\nudge\nudge $h_j \gets f_1 + j\cdot f_2 \bmod m$\\
\nudge\nudge $M[h_j] \gets 1$\\
$\pubaux \gets M$, $\privaux \gets \langle K \rangle$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry(\pubaux,\privaux, q_x)$}\\
$M\gets\pubaux$, $K \gets \privaux$\\
$f_1 \gets F_{K}(\langle 1,x \rangle)$, $f_2 \gets F_{K}(\langle 2,x \rangle)$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets f_1 + j\cdot f_2 \bmod m$\\
\nudge if $M[h_j] \neq 1$ then Return 0\\
Return 1
}
{
\algorithmv{$\Rep(S)$}\\
$\pubaux \gets \emptystring$; $K \getsr \calK$\\
for each $x \in S$\\
\nudge $M_x \gets 0^m$\\
\nudge $B_x \gets \mathsf{bigram}(x)$\\
\nudge for each $b \in B_x$\\
\nudge\nudge $f_1 \gets F_{K}(\langle 1,b \rangle)$, $f_2 \gets F_{K}(\langle 2,b \rangle)$\\
\nudge\nudge for $j \in \{1, 2, \ldots, k\}$\\
\nudge\nudge\nudge $h_j \gets f_1+j\cdot f_2 \bmod m$\\
\nudge\nudge\nudge $M_x[h_j] \gets 1$\\
\nudge $\pubaux \gets \langle\pubaux, M_x \rangle$\\
$\privaux \gets \langle K \rangle$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry(\pubaux,\privaux,q_x)$}\\
$B \gets \mathsf{bigram}(x)$\\
$M_x \gets 0^m$\\
for each $b \in B$\\
\nudge $f_1 \gets F_{K}(\langle 1,b \rangle)$, $f_2 \gets F_{K}(\langle 2,b \rangle)$\\
\nudge for $j \in \{1, 2, \ldots, k\}$\\
\nudge\nudge $h_j \gets f_1+j\cdot f_2 \bmod m$\\
\nudge\nudge $M_x[h_j] \gets 1$\\
if $M_x \in \pubaux$ then Return 1 \\
Return 0
}
\caption{{\bf Left:} $\Rep$ and $\Qry$ algorithms for the linear-PRF
  data structure $\setprim_{\mathrm{lin}}$. {\bf Right:}
Data structure $\setprim_{\bilin}$ from Niedermeyer et
al.~\cite{niedermeyer2014cryptanalysis}. \jnote{Can we not describe
this in terms of $\setprim_{\mathrm{lin}}$?} The $\mathsf{bigram}$
algorithm takes a string~$x=x_1,x_2,\ldots,x_\ell$ as input, and
returns the set of bigrams for the left-and-right-padded string
$\sqcup x \sqcup$, i.e. $\{\sqcup x_1,
x_1x_2,\ldots,x_{\ell-1}x_\ell,x_\ell\sqcup\}$. Both schemes use a
function family $F\colon \calK \times \bits^* \to [m]$.
}\label{fig:lin-and-bi-lin} \label{fig:niedermeyer}
\end{figure}

\subsection{Linear PRF-hash Bloom Filter }
%\heading{Linear-PRF construction. }

\jnote{The BF, DS-PRF, and Linear PRF data structures are all the
same underlying construction but using different instantiations of
the hash functions. Can we just express them all as, e.g.,
$\Pi_{BF}(H_1, \ldots, H_k)$ with different choices for the~$H$'s?
Similarly, the names should be consistent; maybe ``RO Bloom
filter,'' ``independent-PRF Bloom filter,'' and
``pairwise-independent-PRF Bloom filter''?}

The domain-separated PRF data structure requires~$k$ PRF evaluations
per set-membership query.  Kirsch and
Mitzenmacher~\cite{kirsch2006less} studied a variant, which uses
just two PRF evaluations per query, in which the indices $h_j$ of
the array that get set for a given element $x$ are (essentially)
computed as $h_j = F_K(\langle 1,x \rangle) + j\cdot F_K(\langle 2,x
\rangle) \bmod m$ (where $m$ is the length of the array); see
Figure~\ref{fig:lin-and-bi-lin} (left side).
%shown that two PRF evaluations suffice, defining the hash functions
%to be $h_i(x)=F_K(\langle 1,x \rangle) + j\cdot F_K(\langle 2,x
%\rangle) \bmod m$, where~$m$ is the bit-length of the Bloom
%filter.\footnote{Actually, they define $h_i(x)=F_{K_1}(x)  + j\cdot
%F_{K_2}(x) \bmod m$, using distinct keys instead of
%domain-separation, but the constructions are equivalent with respect
%to security.}
We call this the \emph{linear PRF-hash} Bloom filter, and denote it
by $\setprim_{\mathrm{lin}}$. \jnote{Maybe call it
``Pairwise-independent hash''?} In this section, we show that this
scheme is both correct and private.

\jnote{I was not happy with the paragraph contrasting these results
with those of the next section. The attack on by Niedermeyer has
nothing to do with the hash functions used; it is due to the fact
that they work on bigrams.}
%Looking ahead, in the next section we
%will analyze a closely related construction that was attacked by
%Niedermeyer et al.~\cite{niedermeyer2014cryptanalysis}. That
%construction computes indices $h_j$ in the same way, but does not
%ensure that $F$ is evaluated on \emph{distinct} values; that
%construction is \emph{not} private.
%\todo{It would be better, perhaps, to show that it is not OW secure, since this implies it isn't SS secure, and OW security is what Niedermeyer et al. violate.}
%This illustrates that the privacy of the linear PRF-hash
%construction can be sensitive to its usage.


\heading{Correctness. } The following result shows, informally, that
if~$F$ is a good PRF, then $\setprim_{\mathrm{lin}}$ is correct
against adaptive error-finding adversaries.

\jnote{Again, the theorem should not refer to specific adversaries,
but should instead refer to given resource bounds.}

\begin{theorem}%[{\rm Correctness of linear-PRF}]
\label{thm1}\label{thm:lin-correctness} Fix $k,m,n,r>0$ and~$\elts$,
and let $\setprim_{\mathrm{lin}}= (\Rep, \Qry)$ be the
set-membership data structure over~$\elts$.  For any adversary~$A$
that makes a total of~$q_T$ queries to its $\Test$ oracle and runs
in time~$t$, there exist~$B_1,B_2$ such that
\[
\AdvCorrect{\setprim_{\mathrm{lin}},r}{A} \leq  \AdvPRF{F}{B_1} + \AdvPRF{F}{B_2}  +{\dbinom{q}{r}} \cdot \left( (1-e^{-kn/m})^k + O(1/n) \right)^r\,.
\]
Here, $B_1$ and $B_2$ each ask~$q$ oracle queries and run in
time~$O(t+qm)$.
\end{theorem}
Kirsch and Mitzenmacher~\cite{kirsch2006less} show that the ($r=1$,
zero-query) error-probability for~$\setprim_\mathrm{lin}$ is always
within $O(1/n)$ of $(1-e^{-kn/m})^k$, although the asymptotic rate
of convergence is faster than~$1/n$; the multiplicative term
$\binom{q}{r}$ arises due to switching from the zero-query setting
to the adaptive setting. A proof of the above will appear in the
full version, but we remark that it closely follows the proof of
Theorem~\ref{thm:bf-correctness}.
%\input{lin-correctness}


\heading{Privacy. } Simulation-based privacy of the linear PRF-hash
construction follows from~Theorem~\ref{thm:priv-ss}.

\begin{theorem}%[{\rm SS-privacy of linear-PRF}]
\label{thm:lin-privacy} Fix $k,m,n>0$ and $\elts$, and let
$\setprim_{\mathrm{lin}}= (\Rep, \Qry)$ be the set-membership data
structure over~$\elts$. Let $\leak(S)=|S|$.  Then \jnote{Need to
rewrite theorem statement.}
\[
\AdvPrivSS{\setprim_{\mathrm{ds}},\leak}{A,\Sim} \leq  \AdvPRF{F}{B}\;.
\]
%(Both~$B$ and~$\Sim$ are explicitly constructed in the proof of this theorem.)
\end{theorem}
\begin{proof}
Let $\ell(n) = 2n$, let $\Rep_1$ be the algorithm that, on input a
set $S=\{x_1,\ldots,x_n\}$, outputs $\{\langle b,x_i \rangle\}_{b\in
\{1,2\}, i \in [n]}$, and let $\Rep_2$ be the algorithm that, on
input $n,y_{1,1}, y_{2,1}, \ldots, y_{1,n}, y_{2,n}$,  initializes
an $m$-bit array $M$ to~0 and then sets $M[y_{1,i}+j \cdot y_{2,i}
\bmod m] \gets 1$ for $i \in [n]$ and $j \in [k]$. One can easily
verify that $(\Rep_1, \Rep_2, \ell, F)$ is a factoring
of~$\Pi_{\mathrm{ds}}$. Theorem~\ref{thm:priv-ss} yields the claimed
result. \hfill\qed
\end{proof}

%%%%%%%%%%%%%%%%% BIGRAM LINEAR-PRF (AKA "NIEDERMEYER")  %%%%%%%%%%%%%%%%%%%%
\subsection{Bigram Linear-PRF Construction}
%\heading{Bigram Linear-PRF construction (``Niedermeyer''). }
%\heading{Correctness.}
%\todo{Correctness theorem for this scheme.  Should follow pretty closely the one for ``plain'' linear-PRF.}\tsnote{Actually not sure this is that interesting, but for parallel structure one would want to give it.}
Consider the set-membership data structure given in
Figure~\ref{fig:lin-and-bi-lin} (right side), which we call the
\emph{bigram linear-PRF} construction. \jnote{Really a bad
name\ldots} This construction is of interest as it has been
suggested as a way to address the privacy-preserving record-linkage
problem, in particular for linking common records in medical
databases~\cite{niedermeyer2014cryptanalysis}. %,schnell2011novel}.
\jnote{We should really give more discussion, explaining the data
structure in words, and also discussing the goal of
``privacy-preserving record linkage'' and describing the protocol
for doing so (at a high level).}

\heading{Privacy. } We only address the privacy of this
construction, as the correctness follows immediately from the
correctness of the linear PRF-hash construction. \jnote{Well, with
some loss of parameters.} The privacy, however, does not.
%JK
Here we
exhibit an efficient SS-privacy attack even when simulator is
provided nearly the entire set. Consider the following
``all-but-last'' leakage function. On input a
set~$S=\{x_1,x_2,\ldots,x_n\}$, it assigns $x'_n \gets
x_n[1:|x_n|-1]$ and returns
$\mathsf{leak_{abl}}(S)=\{x_1,x_2,\ldots,x'_n\}$.

\begin{figure}[tp]
\centering
\fpage{.65}
{
\adversaryv{$A$}\\[1ex]
On input $\emptystring$:\\
\nudge $x_1 \gets \mathrm{cab}$\\
\nudge $x_2 \gets \mathrm{bab}$\\
\nudge $z \getsr \bits$\\
\nudge if $z=1$ then $x_3 \gets \mathrm{caba}$\\
\nudge else $x_3 \gets \mathrm{cabc}$\\
\nudge Return $S=\{x_1,x_2,x_3\}$\\
On input $\pub \neq \emptystring$:\\
\nudge $M_1,M_2,M_3 \gets \pub$\\
\nudge $M_{1,2} \gets M_1 \vee M_2$\\
\nudge if $z=1 \wedge \left(3k < \mathsf{hamming}(M_{1,2} \wedge M_3) = 4k\right)$ then \\
\nudge\nudge Return 1 \\
\nudge if $z=0 \wedge \left(\mathsf{hamming}(M_{1,2} \wedge M_3) \leq 3k\right)$ then \\
\nudge\nudge Return 1 \\
\nudge Return 0
}
\caption{Adversary for Theorem~\ref{thm:bi-lin-ss}. The function $\mathsf{hamming}(M)$ returns the hamming weight of~$M$.}
\label{fig:adv-bi-lin-ss}
\end{figure}

\begin{theorem}[{\rm SS-privacy of bigram linear-PRF}]\label{thm:bi-lin-ss}
Let $\setprim_{\bilin}= (\Rep, \Qry)$ be the set-membership data
structure described in Figure~\ref{fig:lin-and-bi-lin}, but with
$F_{K}$ replaced by a random function~$\rho$. Let
$\leak_{\mathsf{abl}}$ be the leakage function just described.
Let~$\elts=\{\mathrm{a,b,c}\}^*$. Let $n=3$,  $m=3\alpha $ for
integer $\alpha >> 1$, and let, $k = \lceil \ln(2) \alpha
\rceil$.\footnote{This value of~$k$ is from the classical analysis for
minimizing the FP rate for a Bloom filter, and is set this way for
compatibility with classical results.  It isn't used in any
essential way in the proof sketch.}  Let~$A$ be the adversary in
Figure~\ref{fig:adv-bi-lin-ss}.  Then for any simulator $\Sim$, the
advantage
$\AdvPrivSS{\setprim_{\bilin},\leak_{\mathsf{abl}}}{A,\Sim}$ can be
made arbitrarily close to $1/2$ by choice of~$\alpha$.
\end{theorem}
\begin{proof}%\tsnote{still a bit sketchy but believable}
On input the set~$S$ produced by~$A$, the $\Rep$ algorithm turns $x_1=$'cab', $x_2=$'bab' and $x_3$ into their respective bigram sets: $B_{x_1}=\{\sqcup\mathrm{c},\mathrm{ca},\mathrm{ab},\mathrm{b}\sqcup\}$, $B_{x_2}=\{\sqcup\mathrm{b},\mathrm{ba},\mathrm{ab}, \mathrm{b}\sqcup \}$; the set $B_{x_3}$ will be either $\{\sqcup\mathrm{c},\mathrm{ca},\mathrm{ab},\mathrm{ba}, \mathrm{a}\sqcup\}$, or $\{\sqcup\mathrm{c},\mathrm{ca},\mathrm{ab},\mathrm{bc}, \mathrm{c}\sqcup\}$, each with probability 1/2.  It then produces $\alpha$-bit arrays $M_1, M_2, M_3$ by hashing the corresponding bigram sets using the hash functions $h_j(s)=\rho_1(s)+ j\rho_2(s) \bmod m$.  Note that for sufficiently large~$m$, each of $M_1,M_2$ will contain exactly $4k$ positions set to 1; this is with overwhelming probability, up to collisions in the hash functions for different bigrams within a given bigram set.  Likewise, $M_{1,2}=M_1 \vee M_2$ will have exactly $6k$ positions set to 1, because $B_{x_1}$ and $B_{x_2}$ share $\mathrm{ab}$ and $\mathrm{a}\sqcup$.

In the case that $B_{x_3}=\{\sqcup\mathrm{c},\mathrm{ca},\mathrm{ab},\mathrm{ba}, \mathrm{a}\sqcup\}$, only one of its elements ($\mathrm{a}\sqcup$) is not in either of $B_{x_1},B_{x_2}$.  Hence, the hamming weight of $M_{1,2}\wedge M_3$ will be $4k$.  On the other hand, when $B_{x_3} = \{\sqcup\mathrm{c},\mathrm{ca},\mathrm{ab},\mathrm{bc}, \mathrm{c}\sqcup\}$, two of its elements ($\mathrm{bc}, \mathrm{c}\sqcup$) are not covered by $B_{x_1},B_{x_2}$.  In this case, the hamming weight of $M_{1,2} \wedge M_3$ will be $3k$.  Thus $\ExpPrivSSreal{\setprim_{\bilin}}{A}=1$ with overwhelming probability.

On the other hand, the simulator~$\Sim$ is given 'cab','bab','cab' as
input.  It can perfectly simulate $M_1,M_2$ by lazily sampling random
function~$\rho$ itself.  However, it has no information about the
bit~$z$, so at best it can cause~$A$ to output 1 with
probability~$1/2$.  That is $\ExpPrivSSsim{\setprim_{\bilin}}{A,\Sim} \leq 1/2$. \hfill\qed
\end{proof}




%%%%%%%%%%%%%%%%% Bigram DOMAIN-SEPARATED PRF %%%%%%%%%%%%%%%%%%%%
\subsection{Bigram Domain-Separated PRF-Hash}

\begin{figure}[tp]
\centering
\fpage{0.75}{
\hpagess{.5}{.45}{
\algorithmv{$\Rep(S)$}\\
$\pubaux \gets \emptystring$, $K \getsr \calK$\\
for each $x \in S$\\
\nudge $M_x \gets 0^m$\\
\nudge $B_x \gets \mathsf{bigram}(x)$\\
\nudge for each $b \in B_x$\\
\nudge\nudge for $j \in [k]$\\
\nudge\nudge\nudge $i \gets F_{K}(\langle j, b\rangle) \bmod m$\\
\nudge\nudge\nudge $M_x[i] \gets 1$\\
\nudge $\pubaux \gets \langle\pubaux, M_x \rangle$\\
$\privaux \gets K$\\
Return $(\pubaux,\privaux)$\\
}
{
\algorithmv{$\Qry(\pubaux,\privaux,q_x)$}\\
$B \gets \mathsf{bigram}(x)$\\
$\overline{M} \gets 0^m$\\
for each $b \in B$\\
\nudge for $j \in [k]$\\
\nudge\nudge $i \gets F_{K}(\langle j,b \rangle) \bmod m$\\
\nudge\nudge $\overline{M}[i] \gets 1$\\
if $\overline{M} \in \pubaux$ then Return 1 \\
Return 0
}
}
\caption{Bigram domain-separated PRF-hash.}
\label{fig:DS-bigram}
\end{figure}


Niedermeyer et al.~\cite{niedermeyer2014cryptanalysis} suggest
replacing the linear-PRF hash functions in the previous construction
with independently keyed PRFs as a countermeasure to their attack.
In terms of SS-privacy, however, this change offers no help.  The
following theorem is proved via a nearly identical argument as
Theorem~\ref{thm:bi-lin-ss}.

\begin{theorem}[{\rm SS-privacy of bigram DS PRF-hash}]\label{thm:bi-ds-ss}
Let $\setprim_{\bilin}= (\Rep, \Qry)$ be the set-membership data
structure described in Figure~\ref{fig:DS-bigram}. Let $\leak$ be
the leakage function described just prior to
Theorem~\ref{thm:bi-lin-ss}. Let~$\elts=\{\mathrm{a,b,c}\}^*$. Let
$n=3$,  $m=3\alpha $ for integer $\alpha >> 1$, and let $k = \lceil
\ln(2) \alpha \rceil$.\footnote{As before, this value of~$k$ is from the
classical analysis for minimizing the FP rate for a Bloom filter,
and is set this way for compatibility with classical results.  It
isn't used in any essential way in the proof sketch.}  Let~$A$ be
the adversary in Figure~\ref{fig:adv-bi-lin-ss}.  Then for any
simulator $\Sim$, the advantage
$\AdvPrivSS{\setprim_{\mathrm{ds}},\leak}{A,\Sim}$ can be made
arbitrarily close to $1/2$ by choice of~$\alpha$.
\end{theorem}

On the other hand, we can show that this data structure \emph{is}
secure with respect to a different leakage function, namely, one
that leaks the sizes of the intersections of the various bigram
sets. Specifically, for a set $S$ define ${\sf leak}_\cap(S)$ via
the following algorithm:

\begin{figure}[h]
\centering
\fpage{0.5}{
\algorithmv{${\sf leak}_\cap(S)$}\\
$L \gets \emptystring$\\
for each $x \in S$\\
\nudge $B_x \gets \mathsf{bigram}(x)$\\
for each $S' \subseteq S$\\
\nudge $L \gets \left\langle L, \; \left| \bigcap_{x \in S'} B_x \right| \right\rangle$\\
Return $L$}
%\caption{Bigram domain-separated PRF-hash.}
\end{figure}

\begin{theorem} \label{thm:bi-ds-prf-priv-ss}
Let $\Pi$ be the set-representation data structure in
Figure~\ref{fig:DS-bigram}. Then for any attacker $A$, there is an
attacker $B$
%\jnote{How do we describe the number of PRF queries $B$
%makes? Same problem as in Theorem~\ref{thm:priv-ss}.}
for which
$\AdvPrivSS{\setprim,{\sf leak}_\cap}{A} \leq \AdvPRF{F}{B}$.
\end{theorem}

We remark that the running time of the simulator is exponential in
the size $|S|$ of the set, so the above is not entirely satisfactory
unless $S$ is small. Nevertheless, it does convey the intuition that
the information leaked by the data structure is \emph{at most} the
sizes of the various intersections of the~$\{B_x\}$.

\begin{proof}
The proof follows the same high-level ideas as in the proof of
Theorem~\ref{thm:priv-ss}, based on the observation that ${\sf
leak}_\cap(S)$ suffices to determine the overlap in calls to the
pseudorandom function~$F$.

Our simulator $\Sim$ (see Figure~\ref{fig:sim-bi-ds-prf}), on input $L = \{n_{S'}\}_{S' \subseteq S}$,
proceeds as follows. Let $N = n_S$ denote the size of~$S$. The
simulator constructs $N$ sets $B_1, \ldots, B_N \subset \{e_1,
\ldots, e_{N'}\}$ of ``dummy elements'' $e_1, \ldots, e_{N'}$ (with
$N' \leq N$), such that the sizes of the intersections of the
$\{B_i\}$ are exactly that given by~$L$. (This can be done via a
deterministic, incremental algorithm in which $\Sim$ first populates
$B_1$ with $n_{\{x_1\}}$ dummy elements,and always populates the
next set $B_i$ with old/new dummy elements as needed to maintain the
correct intersection sizes.) It then chooses uniform values
$y_{1,1}, \ldots, y_{1,k}, \ldots, y_{N',1}, \ldots, y_{N',k} \getsr
\bool^{\ell_{out}}$ and computes

\begin{figure}[th]
\centering
\fpage{0.5}{
\algorithmv{$\Sim(\leak(S))$}\\
$\pubaux \gets \emptystring$\\
for each $x \in [N]$\\
\nudge for each $b \in [N']$\\
\nudge \nudge if $e_b \in B_i$\\
\nudge\nudge\nudge for $j \in [k]$\\
\nudge\nudge\nudge\nudge $i \gets y_{b,j} \bmod m$\\
\nudge\nudge\nudge\nudge $M_x[i] \gets 1$\\
\nudge $\pubaux \gets \langle\pubaux, M_x \rangle$\\
Return $\pubaux$
}
\caption{Simulator for the proof of Theorem~\ref{thm:bi-ds-prf-priv-ss} }
\label{fig:sim-bi-ds-prf}
\end{figure}

The proof that this provides a good simulation is identical to that
of Theorem~\ref{thm:priv-ss}. \hfill\qed
\end{proof}


%%%%%%%%%%%%%%%%% GARBLED BF  %%%%%%%%%%%%%%%%%%%%
\subsection{Garbled Bloom Filter}
\begin{figure}[tp]
\centering
\fpage{.8}{
\hpagess{.55}{.45}
{
\algorithmv{$\Rep^H(S)$}\\
$M \gets (\bot)^m$\\
%$K_1,K_2,\ldots, K_k \getsr \calK$\\
for $x \in S$\\
\nudge $\finalshare \gets 0^\lambda$; $\emptyslot \gets -1$\\
\nudge for $j \in \{1,2,\ldots, k\}$\\
\nudge \nudge $h_j \gets H(j,x)$\\
\nudge \nudge if $M[h_j] \neq \bot$ then\\
\nudge \nudge \nudge $\finalshare \gets \finalshare \xor M[h_j]$\\
\nudge \nudge else if $\emptyslot = -1$ then\\
\nudge \nudge \nudge $\emptyslot \gets h_j$\\
\nudge \nudge else\\
\nudge \nudge \nudge $M[h_j] \getsr \bits^\lambda$\\
\nudge \nudge \nudge $\finalshare \gets \finalshare \xor M[h_j]$\\
\nudge $M[\emptyslot] \gets \finalshare \xor x$\\
for $i \in \{1,2,\ldots, m\}$\\
\nudge if $M[i] = \undefined$ then\\
\nudge \nudge  $M[i] \getsr \bits^\lambda$\\
$\pubaux \gets \emptystring$; $\privaux \gets \langle M\rangle$ \mbox{ (if private~$M$)}\\
$\pubaux \gets \langle M \rangle$; $\privaux \gets \emptystring$ \mbox{(if public~$M$)}\\
}
{
\algorithmv{$\Qry^H(\pubaux,\privaux,\qry_x)$}\\
if $\privaux \neq \emptystring$ then $M \gets \privaux$\\
else $M\gets \pubaux$\\
$x' \gets 0^\lambda$\\
for $j \in \{1,2,\dots,k\}$\\
\nudge $h_j \gets H(j,x)$\\
\nudge $x' \gets x' \xor M[h_j]$\\
if $x' =x $ then Return 1\\
Return 0
}
}
\caption{ $\Rep$ and $\Qry$ algorithms for garbled Bloom
  filter $\setprim_{\mathrm{garbled}}$ in the ROM.hash function $H\colon \calK \times
 \elts \to [m]$. The query set is $\calQ=\{\qry_x\colon
  \univ \to \bits\}$ where $\qry_x(S)=1 \Leftrightarrow x \in S$.}
\label{fig:gbf}
\end{figure}


\begin{figure}[tp]
\centering
\hfpagess{.45}{.45}
{
\adversaryv{$A_{\mathrm{ss}}^{\TestOracle,H}(\pubaux)$}\\[1ex]
$M \gets \pubaux$\\
for $\ell=1$ to $\binom{m}{k}$\\
\nudge $i_1,i_2,\ldots,i_k \gets \mathcal{I}_\ell$\\
\nudge $x \gets M[i_1] \xor M[i_2] \xor \cdots \xor M[i_k]$\\
\nudge if  $x \not\in S \wedge \left(\bigwedge_{j=1}^k H(j,x)=i_j \right)$ then \\
\nudge\nudge $a\gets\TestOracle(x)$\\
\nudge\nudge Return $\bot$\\
}
{
\adversaryv{$A_{\mathrm{ow}}^{H}(\pubaux)$}\\[1ex]
$M \gets \pubaux$\\
for $x \in X_1,X_2,\ldots,X_{q-1}$\\
\nudge for $j=1$ to $k$ \\
\nudge \nudge \nudge $i_j \gets H(j,x)$\\
\nudge $x' \gets M[i_1] \xor M[i_2] \xor \cdots \xor M[i_k]$\\
\nudge if $x' = x$ then Return $x$\\
Return~$X_{q}$
}
%{
%\adversaryv{$A^{\TestOracle}(\pubaux)$}\\[1ex]
%$M \gets \pubaux$\\
%for $1 \leq i_1 < i_2 < \cdots < i_k \leq m$\\
%\nudge $x \gets M[i_1] \xor M[i_2] \xor \cdots \xor M[i_k]$\\
%\nudge if $\TestOracle(x)=1$ then Return $\bot$
%}
%\caption{Adversary for Theorem~\ref{thm:xxx}.  \textbf{Left:} public hash case, \textbf{Right:} private hash case.}
\caption{{\bf Left:} Correctness attack for garbled Bloom filters with public~$M$.  The sequence $\mathcal{I}_1,\mathcal{I}_2,\ldots$ is some implicit enumeration of~$k$-tuples of indices over $[m]$.
{\bf Right:} One-wayness attack for garbled Bloom filters with public~$M$.  The sequence $X_1,X_2,\ldots,X_q,$ are the~$q$ most probable points in the support of~$\distr{}{}$ in decreasing order.  }
\label{fig:adv-gbf}
\end{figure}
Dong, Chen and Wen~\cite{CCS:DonCheWen13} introduce a set-membership
data structure called a \emph{garbled Bloom filter} (GBF).   Modulo
some implementation details, a GBF is like a classical Bloom filter,
but rather than storing a bit 1 at the indices determined by
$H_j(x)$, the GBF stores xor-shares of~$x$.  Thus, if $x \in S$,
then hashing~$x$ and xoring together the strings stored at the
indicated positions recovers~$x$. We give the pseudocode for the GBF
$\Rep$ and $\Qry$ algorithms in Figure~\ref{fig:gbf}.

In~\cite{dong2013private} the GBF is a central piece of a private set-intersection
scheme, in which the client computes a classical BF over its
set~$S_1$, the server computes a GBF over its set~$S_2$, and then an
oblivious transfer protocol is carried out, at the end of which the
client obtains a GBF for $S_1 \cap S_2$ (the server learns nothing).
The authors note that the GBF is a new set-membership data structure
that may be of general interest, so we explore its correctness and
privacy with respect to use case that may or may not make the
representation~$M$ public. The pseudocode in Figure~\ref{fig:gbf}
covers both possibilities.

\heading{Correctness.}
We note that~\cite{dong2013private} provides error-rate analysis, i.e., the
probability of finding a single false-positive in a non-adaptive
attack.  When $\lambda$ is the bit-length of the xor-shares, they
argue that the error-rate is at most $2^{-\lambda}$, roughly because
the xor-shares stored in~$M$ are random strings.  (Note that
  this is independent of~$k,m,n$; although $k>1$ is required for the
  xor shares.)  However, this analysis implicitly assumes that the potential false-positive string~$x$ is fixed
\emph{before}~$M$ is determined.  We will see that this carries over
 to the case in which~$M$ is private (i.e.,
$\pubaux=\emptystring,\privaux=\langle M \rangle$), but when~$M$ is
public things are different.

Consider the adversary described in the left half of
Figure~\ref{fig:adv-gbf}.  In one round of the for-loop, it pics~$k$
positions $i_1,i_2,\ldots,i_k$, and xors the strings at these
positions to get a candidate~$x$.   If $x \in S$, which the
adversary knows in the correctness experiment, then it moves on to a
new set of positions.  If $x \not\in S$ and $h_{1}(x)=i_1 \wedge
h_2(x)=i_2 \wedge \cdots \wedge h_k(x) = i_k$, then it \emph{must
be} that $x$ is a false-positive.   Indeed, note that the
probability of this (in the ROM) is precisely the false-positive
rate of a classical Bloom filter using the same $(k,m,n)$ as the
GBF.

Now, this adversary will find a false positive, if there is one, but in the worst case it will consider
$\binom{m}{k} \approx m^k$ $k$-tuples of positions.  If both~$m$
and~$k$ are large this is infeasible.  In~\cite{dong2013private} they suggest to
set~$k=\lambda$, and test with $\lambda=80$.  Making 80 hash calls per
set-membership query would be prohibitive in many applications, and a
$2^{-80}$ false-positive rate would be typically considered overkill in
practice.\footnote{Note
that, as described in~\cite{dong2013private}, $\lambda$ must be at least the
bit-length of the longest element $x \in S$. In practice, this could be
  handled with a slight change to the set membership test, by checking
if the $\lambda$-bit shares xor to, say, the $\lambda$-bit truncation
of~$x$.}
Let us consider a practically interesting set of parameters. Say you have a 1000-position
filter, $m=1000$, and a 100-element set, $n=100$,  and $k=4$ hash
functions (a la Squid~\cite{fan2000summary}).  This results in a false-positive rate of
approximately 1\% in a classical BF.  There are roughly $2^{35}$
subsets of four indices to consider, which is reasonable on a
commodity laptop.  Moreover, with $n=100$ the expected
number of trials is roughly $2^{28}$.
Note that the attack is easily extended to find $r>1$ false positives.

We admit that attack is not particularly sophisticated, yet it might
be significantly more efficient than brute force guessing.  When $k,m,n$ are as in the example just given, and $\elts=\bits^{128}$,
this attack will be considerably faster even if the attacker knows that the distribution deviates significantly from uniform.   Note that in the ROM, the order in which $k$-tuples are considered is largely irrelevant, especially when $2^\lambda \gg \binom{m}{k}$.
%Notice,too, that you \emph{cannot} mount it against a standard Bloom filter.

Finally, we observe that a similar version of the correctness attack
works outside of the ROM, say, when we hash via $H(j,x)=F_K(\langle
j,x \rangle)$ and assume~$F_K$ is a secure PRF.  Here,
$\privaux=\langle K \rangle$.  Now,
however, the work switches from offline hash evaluations (i.e., random
oracle calls) to online set-membership (i.e., $\TestOracle$) queries.

In the full version of this paper, we will give a correctness bound
for the \emph{private}-$M$ GBF, i.e., $\pubaux=\emptystring,
\privaux=\langle M \rangle$, in the random-oracle model.
%
%\begin{theorem}[{\rm Correctness of private-$M$ GBF in the ROM}]\label{thm:gbf-correctness}
%Fix $k,m,n,r,\lambda>0$, and let $\setprim_{\mathrm{gbf}}=(\Rep, \Qry)$ be the private-$M$ garbled Bloom filter. For any adversary~$A$ that makes a total of~$q_T$ queries to the $\Test$ oracle, and $q_R$ queries to the RO, and has time-complexity~$O(t)$,
%\[
%\AdvCorrect{\setprim_{\mathrm{gbf}},r}{A} \leq \mbox{\fixme{}}
%\]
%\end{theorem}

\heading{Privacy. }
We observe immediately that when~$\pubaux=\langle M \rangle$ the GBF cannot be SS-private (in the ROM) because $\privaux=\emptystring$.  In fact, the correctness attack given above suggests a one-wayness attack in the ROM, too; see the right half of Figure~\ref{fig:adv-gbf}.   The naive attack would simply output the most probable element in the support of the distribution $\distr{}{}$ used in the one-wayness experiment to sample~$S$.  But when~$M$ and the hash functions are available to the attacker, it can carry out set-membership tests for itself.  Thus the adversary on the right of Figure~\ref{fig:adv-gbf} tries the~$q-1$ most probable points, in order, halting with its output as soon as the set-membership test is successful.  If none of these points are yield a successful test, then the next most probable point is output.  It is not hard to conclude the following theorem.

\begin{theorem}[{\rm OW-privacy of public-$M$ GBF}]
Fix $k,m,n,r,\lambda>0$, and let $\setprim_{\mathrm{gbf}}=(\Rep, \Qry)$ be the public-$M$ garbled Bloom filter, in the random-oracle model for~$H$.  Then %\fixme{This probability might not be correct... verify when less tired.}
\[
\AdvPrivOW{\setprim_{\mathrm{gbf}},\distr{}{}}{A_{\mathrm{ow}}} \geq 1 - \left(1-\frac{n}{2^{\mu}} \right)^{q} \geq 1 - e^{-nq/2^\mu}
\]
 where $\mu = H_\infty(\distr{}{})$ is the pointwise min-entropy of~$\distr{}{}$, and $A_{\mathrm{ow}}$ makes $kq$ random-oracle queries.
\end{theorem}
\noindent
We conjecture that this is the optimal attack on the GBF in this setting.

If instantiated with hash functions $H_j(x) = F_K(\langle j,x \rangle)$ and $\privaux = \langle K \rangle$, the SS-privacy of the GBF follows directly from~Theorem~\ref{thm:priv-ss}.
\begin{theorem}[{\rm SS-privacy of GBF with secret hash functions}]
\label{thm:gbf-prf-privacy}
Fix $k,m,n,r,\lambda>0$ and a function family~$F\colon \calK \times
\bits^* \to [m]$.  Let $\setprim_{\mathrm{gbf\mbox{-}prf}}= (\Rep,
\Qry)$ be the garbled Bloom filter with hash functions
$H_j(x)=F_K(\langle j,x \rangle)$ and $\privaux=\langle K \rangle$.
For any set~$S$, let $\leak(S)=|S|$.  There exists a simulator~$\Sim$
and an adversary~$B$ (making $kn$ queries) such that, for any adversary~$A$
\[
\AdvPrivSS{\setprim_{\mathrm{gbf\mbox{-}prf}},\leak}{A,\Sim} \leq  \AdvPRF{F}{B}\;.
\]
%(Both~$B$ and~$\Sim$ are explicitly constructed in the proof of this theorem.)
\end{theorem}
\begin{proof}
It suffices to give the decomposition of $\Rep$ in to $\Rep_1$ and $\Rep_2$ as required by Theorem~\ref{thm:priv-ss}.
On input a set of distinct elements $S=\{x_1,x_2,\ldots,x_n\}$, algorithm~$\Rep_1$ returns $s_1=\langle 1,x_1 \rangle, s_2=\langle 2,x_1 \rangle, \ldots, s_k\langle k,x_1\rangle, s_{k+1}=\langle 1,x_2\rangle, \ldots,\linebreak s_{2k}=\langle k,x_2\rangle, \ldots ,s_{kn+1}=\langle 1,x_n\rangle, \ldots, s_{kn}=\langle k,x_n \rangle$.  On input $n,F_K(s_1),\ldots,\linebreak F_K(s_{kn})$, algorithm $\Rep_2$ carries out the pseudocode of~$\Rep$ in Figure~\ref{fig:gbf}, making use of $F_K(s_1),\ldots,F_K(s_{kn})$ in the obvious way.  It returns~$M$ as $\pubaux$.\hfill\qed
\end{proof}


\ignore{
\begin{verbatim}
%----- LEFT HERE FOR REMINDERS, AND FOR MENTIONING OPEN PROBLEMS IN INTRO-------------------------------%
\end{verbatim}

\todo{Below are two lists of things that we should show.}

\heading{Correctness. }  Here we give security proofs and attacks with respect to the correctness notions.
\begin{itemize}
\item Show Bloom Filter is correct in the ROM. \jnote{Should follow along the lines
of Theorem~2, but taking into account adversary's oracle queries.} [DONE]
\item correctness security/attacks on the bigram/PRF-based double-hashing construction ($h_j(x) = F_{K1}(x) + j\cdot F_{K2}(x) \bmod m$ where the~$x$ are bigrams of names, etc.)
\item correctness-security/attacks on the bigram/domain-separated PRF construction ($h_j(x)=F_K(\langle j,x \rangle) \bmod m$, or just assume range of~$F$ is $[m]$.)
\item correctness-security/attacks Dong, Chen, Wen ``garbled Bloom filter'' construction

\end{itemize}

\heading{Privacy. }
\begin{itemize}
\item Prove that the basic BF, in the ROM, is private.  \tsnote{Not SS, should be OW}
\item Show that the bigram DS-PRF construction is/isn't SS [DONE]
\item Show that the basic BF DS-PRF construction is SS [DONE]
\item Prove privacy bounds for the constructions from NY \tsnote{Follows from Jon's meta-theorem}

\item Cast Niedermeyer Niedermeyer et al.\ attacks on the bigram/PRF-based double-hashing construction (see their paper) into our formalism.  \tsnote{Note that their attack would allow one to recover \emph{every} name, not just one.}

\item Prove a privacy bound for the bigram/PRF-based double-hashing construction that Niedermeyer et al.\ attacks. I expect that the provable security bound is considerably worse than the min-entropy because of the way the representation is made.  (Essentially, the Hamming weight of the representation is a good estimate of the length of the longest surname in filter.)
\jnote{Maybe tailor leakage function appropriately, i.e., so that it only leaks the number of bigrams?}

\item Attack correctness of Dong, Chen, Wen ``garbled Bloom Filter'' construction when the hash functions are public.\tsnote{I give the attack in the related work section.  Copy it here and flesh it out.}  Prove priv-security privacy of construction when hash functions are secret.  \tsnote{Makes the point that the application setting really matters.}

\item Prove privacy bounds of other suggestions, such as the record-level BF from Durham et al.?  This would be a nice pairing with the Niedermeyer et al.\ results \tsnote{No time.}

\end{itemize}
}
