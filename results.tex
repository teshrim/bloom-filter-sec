\section{Case Studies}
Here we explore various set-membership data structures that have been proposed
in the literature with respect to our definitions.

%%%%%%%%%%%%%%%%% CLASSICAL BLOOM FILTER IN ROM %%%%%%%%%%%%%%%%%%%%

\begin{figure}[tp]
\centering
\hfpagess{.4}{.4}
{
\algorithmv{$\Rep^H(S)$}\\
$M \gets 0^m$\\
for $x \in S$\\
\nudge for $j \in \{1,2,\ldots,k\}$\\
\nudge\nudge $h_j \gets H(j,x)$\\
\nudge\nudge $M[h_j] \gets 1$\\
$\pubaux \gets M$, $\privaux \gets \emptystring$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry^H(\pubaux,\privaux,q_x)$}\\
$M\gets\pubaux$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets H(j,x)$\\
\nudge if $M[h_j] \neq 1$ then Return 0\\
Return 1
}
{
\algorithmv{$\Rep(S)$}\\
$M \gets 0^m$; $K \getsr \calK$\\
for $x \in S$\\
\nudge for $j \in \{1,2,\ldots,k\}$\\
\nudge\nudge $h_j \gets F_{K}(\langle j,x \rangle) $\\
\nudge\nudge $M[h_j] \gets 1$\\
$\pubaux \gets M$, $\privaux \gets \langle K \rangle$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry(\pubaux,\privaux,q_x)$}\\
$M\gets\pubaux$, $K \gets \privaux$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets F_{K}(\langle j,x \rangle) $\\
\nudge if $M[h_j] \neq 1$ then Return 0\\
Return 1
}
\caption{{\bf Left:} $\Rep$ and $\Qry$ algorithms for classic Bloom
  filter $\setprim_{\mathrm{Bloom}}$ in the ROM for a hash function $H\colon \mathbb{N} \times
  \elts \to [m]$. {\bf Right:} $\Rep$ and $\Qry$
  algorithms for the domain-separated PRF data structure
  $\setprim_{\mathrm{ds}}$, using function family $F \colon
  \calK \times \elts \to [m]$.  Both constructions have query set is $\calQ=\{q_x\colon
  \univ \to \bits\}$ where $q_x(S)=1 \Leftrightarrow x \in S$.  }
\label{fig:bf-and-ds}
\end{figure}

\subsection{Classical Bloom Filter in the Random-Oracle Model}
Fix $n,k,m \geq 0$, and fix a set $\elts$.  Then the classical Bloom
filter set-membership data structure $\setprim_{\mathrm{Bloom}}=
(\Rep, \Qry)$ over~$\elts$ is defined as in
Figure~\ref{fig:bf-and-ds} (left side).  We
define~$\setprim_{\mathrm{Bloom}}$ in the random-oracle model
(ROM), as the traditional analysis of Bloom filter correctness (as a
function of $n,k,m$) is done in this model.\footnote{The standard
model version would have $\Rep$ choose $H_1,H_2,\ldots,H_k$ from a
hash function family, compute $h_j$ using these, and placing their
description in $\pubaux$.}

\heading{Correctness. } The following theorem proves that the Bloom
filter meets our correctness notion in the ROM.  Again, we stress
that this correctness is with respect to adaptive adversaries,
aiming to find $r \geq 1$ errors (in this case, false-positives).


\begin{theorem}\label{thm3}\label{thm:bf-correctness}
Fix $k,m,n,r>0$ and a set~$\elts$, and let
$\setprim_{\mathrm{Bloom}}= (\Rep, \Qry)$ be the classical Bloom
filter (set-membership) data structure over~$\elts$. For any
adversary~$A$ that makes a total of~$q_T$ queries to the $\Test$
oracle, and $q_R$ queries to the RO, and has time-complexity~$O(t)$,
\[
\AdvCorrect{\setprim_{\mathrm{Bloom}},r}{A} \leq  {\dbinom{q_T + q_H-1}{r-1}} \left( (1-e^{-kn/m})^k + O(1/n) \right)^r\,.
\]
\end{theorem}
We note that Kirsch and Mitzenmacher~\cite{kirsch2006less} show
that the ($r=1$, zero-query) error-probability for~$\setprim_\mathrm{Bloom}$ is
always within $O(1/n)$ of $(1-e^{-kn/m})^k$, although the asymptotic
rate of convergence is faster than~$1/n$.  The multiplicative (``hybrid'') term arises as a result
of moving from the adaptive to the zero-query setting.
Finally, $\binom{q_T+q_H-1}{r-1} \leq (q_T+q_H)^r$ (with reasonable tightness when~$r$ is small) in
which case the final term in the bound behaves as
$((q_T+q_H) (1-e^{-kn/m})^k + O(q/n) )^r$; loosely, this is the bound one expects for
trying to find a single correctness error (in this case, a false positive) in each of~$r$ independent``rounds'', each round
consisting of~$(q_T+q_H)$ attempts.
\input{BF_correctness}

\heading{Privacy. }
Turning to privacy, we observe immediately that the classical BF, in the
ROM, does not meet our SS-privacy notion when the leakage function
fails to reveal the entire set~$S$.  This is because the set~$S$ is
adversarially chosen, and the adversary has access to the random
oracle, i.e. the hash functions used to make~$\pubaux$.  Thus the
adversary can simply check that the $\pubaux$ it receives is correct.
Thus, unless $m,k,n$ are such that the false-positive rate is large,
the simulator needs to call the random oracle on the points in~$S$ in order to ``fool'' the adversary.
%\tsnote{I'm still not completely comfortable with this.  It isn't explicit in our SS notion, but I assume that~$A$ is stateful and so knows~$S$ in its second stage?  If so, I wonder if the classic BF in the ROM would be secure relative to a weaker notion (but still stronger than OW) in which the second stage does not know~$S$?  This seems likely to me.}

We note that this will be true for \emph{any} data structure that returns an empty $\privaux$, because this implies that $\pubaux$ alone suffices to evaluate $\Qry(\pubaux,\privaux,\cdot)$.

\begin{theorem}[{\rm OW-privacy of classic BF in the ROM}]\label{thm3}\label{thm:bf-ow}
Fix $k,m,n,r>0$, a set~$\elts$, and let $\setprim_{\mathrm{Bloom}}= (\Rep, \Qry)$ be the classical Bloom filter data structure over~$\elts$. Let $\distr{}{}$ be a distribution over subsets of universe~$\univ=2^\elts$, where $\mu = H_\infty(\distr{}{})$.  For any adversary~$A$ that makes $q$~queries to its oracle
\[
\AdvPrivOW{\setprim_{\mathrm{Bloom}},\distr{}{},r}{A} \leq  \frac{(kqn+n)}{2^{\mu}}\;.
\]
\end{theorem}
The straightforward proof will appear in the full version.
Loosely, the $kqn/2^{\mu}$ term arises from the chance that random-oracle queries reveal an element of~$S$ (by the random oracle having
been called on them in the execution of~$\Rep$), and the $n/2^\mu$
term arises to simple guessing of an element of~$S$ should none of the
random-oracle queries reveal an element of~$S$.

%%%%%%%%%%%%%%%%% DOMAIN-SEPARATED PRF %%%%%%%%%%%%%%%%%%%%

\subsection{Domain-Separated PRF-Hash}
\jnote{Give English-language description of scheme before turning to
analysis of correctness.}

%\heading{Construction of PRF with domain separation.}
\heading{Correctness. } Let $\setprim_{\mathrm{ds}}= (\Rep, \Qry)$
be the set-membership data structure defined on the right-hand side
of Figure~\ref{fig:bf-and-ds}. As in the preceding theorem, the
following says (informally) that if~$F$ is a secure PRF, then this
domain-separated PRF construction is correct against adaptive
adversaries.

% \tsnote{Not really appropriate to say this next thing; I'll add a new section that addresses bigram DS-PRF hash.}
% We note that Neidermayer et
% al. in~\cite{xxx} suggest replacing the linear-PRF hash functions in
% the previous construction with independently keyed PRFs as a way to
% thwart their attacks.  The construction we consider now achieves the
% same end, albeit via explict domain separation rather than separate
% keys.

\begin{theorem}[{\rm Correctness of DS-PRF}]\label{thm2}\label{thm:ds-correctness}
Fix $k,m,n,r>0$, a set~$\elts$, and let $\setprim_{\mathrm{ds}}= (\Rep, \Qry)$ be the set-membership data structure (over~$\elts$) in Figure~\ref{fig:bf-and-ds}.  For any adversary~$A$ that makes a total of~$q$ queries to its oracle and has time-complexity~$O(t)$, there exists a prf-adversary ~$B$ (explicitly constructed in the proof of this theorem) such that
\[
\AdvCorrect{\setprim_{\mathrm{ds}},r}{A} \leq  \AdvPRF{F}{B}  + {\dbinom{q}{r}} \left( (1-e^{-kn/m})^k + O(1/n) \right)^r\,.
\]
Here, $B$ asks $q$ queries, and has time complexity $O(t+qm)$.
\end{theorem}
We note that Kirsch and Mitzenmacher~\cite{kirsch2006less} show
that the ($r=1$, zero-query) error-probability for~$\setprim_\mathrm{ds}$ is
always within $O(1/n)$ of $(1-e^{-kn/m})^k$, although the asymptotic
rate of convergence is faster than~$1/n$.   As before, the multiplicative term $\binom{q}{r}$ arises when switching from the adaptive to zero-query settings.
\input{ds-correctness}


\heading{Privacy. }
The privacy of $\setprim_{\mathrm{ds}}$ follows directly from our general result, Theorem~\ref{thm:priv-ss}.
\begin{theorem}[\rm{SS-privacy of DS PRF}]\label{thm:ds-ss}
Fix $k,m,n>0$, a set~$\elts$, and let $\setprim_{\mathrm{ds}}= (\Rep,
\Qry)$ be the set-membership data structure described in
Figure~\ref{fig:bf-and-ds}.  For any set~$S \in 2^\elts$, let
$\leak(S)=|S|$.  There exists a simulator~$\Sim$ and adversary~$B$
(making~$kn$ queries) such that, for any adversary~$A$
\[
\AdvPrivSS{\setprim_{\mathrm{ds}},\leak}{A,\Sim} \leq  \AdvPRF{F}{B}\,.
\]
%(Both~$B$ and~$\Sim$ are explicitly constructed in the proof of this theorem.)
\end{theorem}
\begin{proof}
It suffices to give the decomposition of $\Rep$ in to $\Rep_1$ and $\Rep_2$ as required by Theorem~\ref{thm:priv-ss}.
On input a set of distinct elements $S=\{x_1,x_2,\ldots,x_n\}$, algorithm~$\Rep_1$ returns $s_1=\langle 1,x_1 \rangle, s_2=\langle 2,x_1 \rangle, \ldots, s_k\langle k,x_1\rangle, s_{k+1}=\langle 1,x_2\rangle, \ldots,\linebreak s_{2k}=\langle k,x_2\rangle, \ldots ,s_{kn+1}=\langle 1,x_n\rangle, \ldots, s_{kn}=\langle k,x_n \rangle$.  On input $n,F_K(s_1),\ldots,\linebreak F_K(s_{kn})$, algorithm $\Rep_2$ simply initializes an all-zero array~$M$ of~$m$-bits, and sets the positions $M[F_K(s_i)]$ to 1.  It returns~$M$ as $\pubaux$. \hfill\qed
\end{proof}


%%%%%%%%%%%%%%%%% LINEAR-PRF %%%%%%%%%%%%%%%%%%%%
\begin{figure}[tp]
\centering
\hfpagess{.5}{.5}
{
\algorithmv{$\Rep(S)$}\\
$M \gets 0^m$; $K \getsr \calK$\\
for $x \in S$\\
%\jnote{Fix}\tsnote{Fix what?}\\
\nudge $f_1 \gets F_{K}(\langle 1,x \rangle)$, $f_2 \gets F_{K}(\langle 2,x \rangle)$\\
\nudge for $j \in \{1,2,\ldots,k\}$\\
\nudge\nudge $h_j \gets f_1 + j\cdot f_2 \bmod m$\\
\nudge\nudge $M[h_j] \gets 1$\\
$\pubaux \gets M$, $\privaux \gets \langle K \rangle$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry(\pubaux,\privaux)$}\\
$M\gets\pubaux$, $K \gets \privaux$\\
%\jnote{Fix}\tsnote{Fix what?} \\
$f_1 \gets F_{K}(\langle 1,x \rangle)$, $f_2 \gets F_{K}(\langle 2,x \rangle)$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets f_1 + j\cdot f_2 \bmod m$\\
\nudge if $M[h_j] \neq 1$ then Return 0\\
Return 1
}
{
\algorithmv{$\Rep(S)$}\\
$\pubaux \gets \emptystring$\\
$K_1,K_2, \getsr \calK$\\
for each $x \in S$\\
\nudge $M_x \gets 0^m$\\
\nudge $B_x \gets \mathsf{bigram}(x)$\\
\nudge for each $b \in B_x$\\
\nudge\nudge $f_1 \gets F_{K}(\langle 1,b \rangle)$, $f_2 \gets F_{K}(\langle 2,b \rangle)$\\
\nudge\nudge for $j \in [k]$\\
\nudge\nudge\nudge $i \gets f_1+j\cdot f_2 \bmod m$\\
\nudge\nudge\nudge $M_x[i] \gets 1$\\
\nudge $\pubaux \gets \langle\pubaux, M_x \rangle$\\
$\privaux \gets \langle K_1,K_2 \rangle$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry(\pubaux,\privaux,q_x)$}\\
$B \gets \mathsf{bigram}(x)$\\
$\overline{M} \gets 0^m$\\
for each $b \in B$\\
\nudge for $j \in [k]$\\
\nudge\nudge $f_1 \gets F_{K}(\langle 1,b \rangle)$, $f_2 \gets F_{K}(\langle 2,b \rangle)$\\
\nudge\nudge $i \gets f_1+j\cdot f_2 \bmod m$\\
\nudge\nudge $\overline{M}[i] \gets 1$\\
if $\overline{M} \in \pubaux$ then Return 1 \\
Return 0
}
\caption{{\bf Left:} $\Rep$ and $\Qry$ algorithms for the linear-PRF
  data structure $\setprim_{\mathrm{lin}}$ {\bf Right:}
The scheme from Niedermeyer et al.\cite{niedermeyer2014cryptanalysis}, $\setprim_{\bilin}$.
The $\mathsf{bigram}$ algorithm takes a
string~$x=x_1,x_2,\ldots,x_\ell$ as input, and returns the set of
bigrams for the left- and right-padded string $\sqcup x \sqcup$,
i.e. $\{\sqcup x_1, x_1x_2,\ldots,x_{\ell-1}x_\ell,x_\ell\sqcup\}$.
Both schemes use a function family $F\colon \calK \times \bits^* \to [m]$.
}\label{fig:lin-and-bi-lin}
\label{fig:niedermeyer}
\end{figure}

\subsection{Linear PRF-hash Bloom Filter }
%\heading{Linear-PRF construction. }
The domain-separated PRF-hash requires~$k$ PRF evaluations per set-membership query, and this may be unattractive in certain use cases.  Kirsch and Mitzenmacher~\cite{kirsch2006less} have shown that two PRF evaluations suffices, defining the hash functions to be $h_i(x)=F_K(\langle 1,x \rangle) + j\cdot F_K(\langle 2,x \rangle) \bmod m$, where~$m$ is the bit-length of the Bloom filter.\footnote{Actually, they define $h_i(x)=F_{K_1}(x)  + j\cdot F_{K_2}(x) \bmod m$, using distinct keys instead of domain-separation, but the constructions are equivalent with respect to security.} We call this the \emph{linear PRF-hash} Bloom Filter.  In this section, we show that this scheme is both correct and private with respect to our SS notion.

Looking ahead to the next section, we will analyze a closely related construction, which was attacked by Niedermeyer et al.~\cite{niedermeyer2014cryptanalysis} in the context of private medical-record linkage.  It uses the same linear-PRF hash functions, but has a $\Rep$ algorithm that that does not ensure that the hash functions are called on \emph{distinct} values.  We show that this is \emph{not} private with respect to our SS notion for a leakage function that leaks nearly the entire set~$S$. \todo{It would be better, perhaps, to show that it is not OW secure, since this implies it isn't SS secure, and OW security is what Niedermeyer et al. violate.}

Taken together, the results of this section and the next highlight how sensitive the privacy of linear PRF-hash constructions is to usage.


\heading{Correctness. }
For now, let $n,k,m \geq 0$.  Then $\setprim_{\mathrm{lin}}= (\Rep, \Qry)$ is defined as in Figure~\ref{fig:lin-and-bi-lin} (left side).  The following result shows, informally, that if~$F$ is a good PRF, then $\setprim_{\mathrm{lin}}$ is correct against adaptive error-finding adversaries.

\begin{theorem}[{\rm Correctness of linear-PRF}]\label{thm1}\label{thm:lin-correctness}
Fix $k,m,n,r>0$, a set~$\elts$, and let $\setprim_{\mathrm{lin}}= (\Rep, \Qry)$ be the set-membership data structure (over~$\elts$) described in Figure~\ref{fig:lin-and-bi-lin}.  For any adversary~$A$ that makes a total of~$q$ queries to its oracle and has time-complexity~$O(t)$, there exist prf-adversaries~$B_1,B_2$ (explicitly constructed in the proof of this theorem) such that
\[
\AdvCorrect{\setprim_{\mathrm{lin}},r}{A} \leq  \AdvPRF{F}{B_1} + \AdvPRF{F}{B_2}  +{\dbinom{q}{r}} \left( (1-e^{-kn/m})^k + O(1/n) \right)^r\,.
\]
Here, $B_1$ and $B_2$, each ask~$q$ oracle queries and have time complexity~$O(t+qm)$.
\end{theorem}
Again, Kirsch and Mitzenmacher~\cite{kirsch2006less} show
that the ($r=1$, zero-query) error-probability for~$\setprim_\mathrm{lin}$ is
always within $O(1/n)$ of $(1-e^{-kn/m})^k$, although the asymptotic
rate of convergence is faster than~$1/n$.
the multiplicative term $\binom{q}{r}$ arises when switching from the adaptive to zero-query settings.
The proof will appear in the full version, but we note that it very
closely follows the proof of correctness for the DS PRF-hash
construction, Theorem~\ref{thm:ds-correctness}
%\input{lin-correctness}


\heading{Privacy. }
The SS-privacy of the linear-PRF hash construction follows directly from~Theorem~\ref{thm:priv-ss}.
\begin{theorem}[{\rm SS-privacy of linear-PRF}]\label{thm:lin-privacy}
Fix $k,m,n,r>0$, a set $\elts$, and let $\setprim_{\mathrm{lin}}=
(\Rep, \Qry)$ be the set-membership data structure (over~$\elts$)
described in Figure~\ref{fig:lin-and-bi-lin}. For any set~$S \in
2^{\elts}$, let $\leak(S)=|S|$.  There exists a simulator~$\Sim$ and
an adversary~$B$ (making $2n$ queries) such that, for any adversary~$A$
\[
\AdvPrivSS{\setprim_{\mathrm{ds}},\leak}{A,\Sim} \leq  \AdvPRF{F}{B}\;.
\]
%(Both~$B$ and~$\Sim$ are explicitly constructed in the proof of this theorem.)
\end{theorem}
\begin{proof}
It suffices to give the decomposition of $\Rep$ in to $\Rep_1$ and $\Rep_2$ as required by Theorem~\ref{thm:priv-ss}.
On input a set of distinct elements
$S=\{x_1,x_2,\ldots,x_n\}$, algorithm~$\Rep_1$ returns $s_1=\langle 1,x_1 \rangle, s_2=\langle 2,x_1 \rangle, s_3 = \langle 1,x_2\rangle, s_4=\langle 2,x_2 \rangle,\ldots,\linebreak s_{2n-1}=\langle 1,x_n \rangle, s_{2n}=\langle 2,x_n \rangle$.

On input $n,F_K(s_1),F_K(s_2),\ldots,F_K(s_{2n-1}) , F_K(s_{2n})$, algorithm $\Rep_2$ initializes an all-zero array~$M$ of~$m$-bits, and sets the positions $M[F_K(s_i)+j\cdot F_K(s_{i+1})\bmod m]$ to 1, for each $j \in [k]$.  It returns~$M$ as $\pubaux$. \hfill\qed
\end{proof}


%%%%%%%%%%%%%%%%% BIGRAM LINEAR-PRF (AKA "NIEDERMEYER")  %%%%%%%%%%%%%%%%%%%%
\subsection{Bigram Linear-PRF Construction}
%\heading{Bigram Linear-PRF construction (``Niedermeyer''). }
%\heading{Correctness.}
%\todo{Correctness theorem for this scheme.  Should follow pretty closely the one for ``plain'' linear-PRF.}\tsnote{Actually not sure this is that interesting, but for parallel structure one would want to give it.}
\heading{Privacy. }
Consider the set-membership data structure given in Figure~\ref{fig:lin-and-bi-lin} (right side), which we call the \emph{bigram linear-PRF} construction.  This construction is of practical interest, as it has been suggested as a way to address the privacy-preserving record-linkage problem, in particular for linking common records in medical databases~\cite{niedermeyer2014cryptanalysis,schnell2011novel}.
We only address the privacy of this construction, as the correctness follows immediately from the correctness of the Linear-PRF construction.  The privacy, however, does not.  Here we exhibit an efficient SS-privacy attack even when simulator is provided nearly the entire set.  Consider the following ``all-but-last'' leakage function.  On input a set~$S=\{x_1,x_2,\ldots,x_n\}$, it assigns $x'_n \gets x_n[1:|x_n|-1]$ and returns $\mathsf{leak_{abl}}(S)=\{x_1,x_2,\ldots,x'_n\}$.  \todo{OW privacy proof? Or just some text that says that Niedermeyer et al. show something stronger~---OW-privacy violation---~albeit with $n=10000, m=10000\alpha$ for an $\alpha$ that I need to look up.}

\begin{figure}[tp]
\centering
\fpage{.65}
{
\adversaryv{$A$}\\[1ex]
On input $\emptystring$:\\
\nudge $x_1 \gets \mathrm{cab}$\\
\nudge $x_2 \gets \mathrm{bab}$\\
\nudge $z \getsr \bits$\\
\nudge if $z=1$ then $x_3 \gets \mathrm{caba}$\\
\nudge else $x_3 \gets \mathrm{cabc}$\\
\nudge Return $S=\{x_1,x_2,x_3\}$\\
On input $\pub \neq \emptystring$:\\
\nudge $M_1,M_2,M_3 \gets \pub$\\
\nudge $M_{1,2} \gets M_1 \vee M_2$\\
\nudge if $z=1 \wedge \left(3k < \mathsf{hamming}(M_{1,2} \wedge M_3) = 4k\right)$ then \\
\nudge\nudge Return 1 \\
\nudge if $z=0 \wedge \left(\mathsf{hamming}(M_{1,2} \wedge M_3) \leq 3k\right)$ then \\
\nudge\nudge Return 1 \\
\nudge Return 0
}
\caption{Adversary for Theorem~\ref{thm:bi-lin-ss}. The function $\mathsf{hamming}(M)$ returns the hamming weight of~$M$.}
\label{fig:adv-bi-lin-ss}
\end{figure}

\begin{theorem}[{\rm SS-privacy of bigram linear-PRF}]\label{thm:bi-lin-ss}
Let $\setprim_{\bilin}= (\Rep, \Qry)$ be the set-membership data
structure described in Figure~\ref{fig:lin-and-bi-lin}, but with
$F_{K}$ replaced by a random function~$\rho$. Let
$\leak_{\mathsf{abl}}$ be the leakage function just described.
Let~$\elts=\{\mathrm{a,b,c}\}^*$. Let $n=3$,  $m=3\alpha $ for
integer $\alpha >> 1$, and let, $k = \lceil \ln(2) \alpha
\rceil$.\footnote{This value of~$k$ is from the classical analysis for
minimizing the FP rate for a Bloom filter, and is set this way for
compatibility with classical results.  It isn't used in any
essential way in the proof sketch.}  Let~$A$ be the adversary in
Figure~\ref{fig:adv-bi-lin-ss}.  Then for any simulator $\Sim$, the
advantage
$\AdvPrivSS{\setprim_{\bilin},\leak_{\mathsf{abl}}}{A,\Sim}$ can be
made arbitrarily close to $1/2$ by choice of~$\alpha$.
\end{theorem}
\begin{proof}%\tsnote{still a bit sketchy but believable}
On input the set~$S$ produced by~$A$, the $\Rep$ algorithm turns $x_1=$'cab', $x_2=$'bab' and $x_3$ into their respective bigram sets: $B_{x_1}=\{\sqcup\mathrm{c},\mathrm{ca},\mathrm{ab},\mathrm{b}\sqcup\}$, $B_{x_2}=\{\sqcup\mathrm{b},\mathrm{ba},\mathrm{ab}, \mathrm{b}\sqcup \}$; the set $B_{x_3}$ will be either $\{\sqcup\mathrm{c},\mathrm{ca},\mathrm{ab},\mathrm{ba}, \mathrm{a}\sqcup\}$, or $\{\sqcup\mathrm{c},\mathrm{ca},\mathrm{ab},\mathrm{bc}, \mathrm{c}\sqcup\}$, each with probability 1/2.  It then produces $\alpha$-bit arrays $M_1, M_2, M_3$ by hashing the corresponding bigram sets using the hash functions $h_j(s)=\rho_1(s)+ j\rho_2(s) \bmod m$.  Note that for sufficiently large~$m$, each of $M_1,M_2$ will contain exactly $4k$ positions set to 1; this is with overwhelming probability, up to collisions in the hash functions for different bigrams within a given bigram set.  Likewise, $M_{1,2}=M_1 \vee M_2$ will have exactly $6k$ positions set to 1, because $B_{x_1}$ and $B_{x_2}$ share $\mathrm{ab}$ and $\mathrm{a}\sqcup$.

In the case that $B_{x_3}=\{\sqcup\mathrm{c},\mathrm{ca},\mathrm{ab},\mathrm{ba}, \mathrm{a}\sqcup\}$, only one of its elements ($\mathrm{a}\sqcup$) is not in either of $B_{x_1},B_{x_2}$.  Hence, the hamming weight of $M_{1,2}\wedge M_3$ will be $4k$.  On the other hand, when $B_{x_3} = \{\sqcup\mathrm{c},\mathrm{ca},\mathrm{ab},\mathrm{bc}, \mathrm{c}\sqcup\}$, two of its elements ($\mathrm{bc}, \mathrm{c}\sqcup$) are not covered by $B_{x_1},B_{x_2}$.  In this case, the hamming weight of $M_{1,2} \wedge M_3$ will be $3k$.  Thus $\ExpPrivSSreal{\setprim_{\bilin}}{A}=1$ with overwhelming probability.

On the other hand, the simulator~$\Sim$ is given 'cab','bab','cab' as
input.  It can perfectly simulate $M_1,M_2$ by lazily sampling random
function~$\rho$ itself.  However, it has no information about the
bit~$z$, so at best it can cause~$A$ to output 1 with
probability~$1/2$.  That is $\ExpPrivSSsim{\setprim_{\bilin}}{A,\Sim} \leq 1/2$. \hfill\qed
\end{proof}




%%%%%%%%%%%%%%%%% Bigram DOMAIN-SEPARATED PRF %%%%%%%%%%%%%%%%%%%%
\subsection{Bigram Domain-Separated PRF-Hash}

\begin{figure}[tp]
\centering
\fpage{0.75}{
\hpagess{.5}{.45}{
\algorithmv{$\Rep(S)$}\\
$\pubaux \gets \emptystring$, $K \getsr \calK$\\
for each $x \in S$\\
\nudge $M_x \gets 0^m$\\
\nudge $B_x \gets \mathsf{bigram}(x)$\\
\nudge for each $b \in B_x$\\
\nudge\nudge for $j \in [k]$\\
\nudge\nudge\nudge $i \gets F_{K}(\langle j, b\rangle) \bmod m$\\
\nudge\nudge\nudge $M_x[i] \gets 1$\\
\nudge $\pubaux \gets \langle\pubaux, M_x \rangle$\\
$\privaux \gets K$\\
Return $(\pubaux,\privaux)$\\
}
{
\algorithmv{$\Qry(\pubaux,\privaux,q_x)$}\\
$B \gets \mathsf{bigram}(x)$\\
$\overline{M} \gets 0^m$\\
for each $b \in B$\\
\nudge for $j \in [k]$\\
\nudge\nudge $i \gets F_{K}(\langle j,b \rangle) \bmod m$\\
\nudge\nudge $\overline{M}[i] \gets 1$\\
if $\overline{M} \in \pubaux$ then Return 1 \\
Return 0
}
} 
\caption{Bigram domain-separated PRF-hash.}
\label{fig:DS-bigram}
\end{figure}


Niedermeyer et al.~\cite{niedermeyer2014cryptanalysis} suggest
replacing the linear-PRF hash functions in the previous construction
with independently keyed PRFs as a countermeasure to their attack.
In terms of SS-privacy, however, this change offers no help.  The
following theorem is proved via a nearly identical argument as
Theorem~\ref{thm:bi-lin-ss}.

\begin{theorem}[{\rm SS-privacy of bigram DS PRF-hash}]\label{thm:bi-ds-ss}
Let $\setprim_{\bilin}= (\Rep, \Qry)$ be the set-membership data
structure described in Figure~\ref{fig:DS-bigram}. Let $\leak$ be
the leakage function described just prior to
Theorem~\ref{thm:bi-lin-ss}. Let~$\elts=\{\mathrm{a,b,c}\}^*$. Let
$n=3$,  $m=3\alpha $ for integer $\alpha >> 1$, and let $k = \lceil
\ln(2) \alpha \rceil$.\footnote{As before, this value of~$k$ is from the
classical analysis for minimizing the FP rate for a Bloom filter,
and is set this way for compatibility with classical results.  It
isn't used in any essential way in the proof sketch.}  Let~$A$ be
the adversary in Figure~\ref{fig:adv-bi-lin-ss}.  Then for any
simulator $\Sim$, the advantage
$\AdvPrivSS{\setprim_{\mathrm{ds}},\leak}{A,\Sim}$ can be made
arbitrarily close to $1/2$ by choice of~$\alpha$.
\end{theorem}

On the other hand, we can show that this data structure \emph{is}
semantically secure with respect to a different leakage function,
namely, one that leaks the sizes of the intersections of the various
bigram sets. Specifically, for a set $S$ define ${\sf leak}_\cap(S)$
via the following algorithm:

\begin{figure}[h]
\centering
\fpage{0.5}{
\algorithmv{${\sf leak}_\cap(S)$}\\
$L \gets \emptystring$\\
for each $x \in S$\\
\nudge $B_x \gets \mathsf{bigram}(x)$\\
for each $S' \subseteq S$\\
\nudge $L \gets \left\langle L, \; \left| \bigcap_{x \in S'} B_x \right| \right\rangle$\\
Return $L$}
%\caption{Bigram domain-separated PRF-hash.}
\end{figure}

\begin{theorem} \label{thm:bi-ds-prf-priv-ss}
Let $\Pi$ be the set-representation data structure in
Figure~\ref{fig:DS-bigram}. Then for any attacker $A$, there is an
attacker $B$ 
%\jnote{How do we describe the number of PRF queries $B$
%makes? Same problem as in Theorem~\ref{thm:priv-ss}.} 
for which
$\AdvPrivSS{\setprim,{\sf leak}_\cap}{A} \leq \AdvPRF{F}{B}$.
\end{theorem}

We remark that the running time of the simulator is exponential in
the size $|S|$ of the set, so the above is not entirely satisfactory
unless $S$ is small. Nevertheless, it does convey the intuition that
the information leaked by the data structure is \emph{at most} the
sizes of the various intersections of the~$\{B_x\}$.

\begin{proof}
The proof follows the same high-level ideas as in the proof of
Theorem~\ref{fig:DS-bigram}, based on the observation that ${\sf
leak}_\cap(S)$ suffices to determine the overlap in calls to the
pseudorandom function~$F$.

Our simulator $\Sim$ (see Figure~\ref{fig:sim-bi-ds-prf}), on input $L = \{n_{S'}\}_{S' \subseteq S}$,
proceeds as follows. Let $N = n_S$ denote the size of~$S$. The
simulator constructs $N$ sets $B_1, \ldots, B_N \subset \{e_1,
\ldots, e_{N'}\}$ of ``dummy elements'' $e_1, \ldots, e_{N'}$ (with
$N' \leq N$), such that the sizes of the intersections of the
$\{B_i\}$ are exactly that given by~$L$. (This can be done via a
deterministic, incremental algorithm in which $\Sim$ first populates
$B_1$ with $n_{\{x_1\}}$ dummy elements,and always populates the
next set $B_i$ with old/new dummy elements as needed to maintain the
correct intersection sizes.) It then chooses uniform values
$y_{1,1}, \ldots, y_{1,k}, \ldots, y_{N',1}, \ldots, y_{N',k} \getsr
\bool^{\ell_{out}}$ and computes

\begin{figure}[th]
\centering
\fpage{0.5}{
\algorithmv{$\Sim(\leak(S))$}\\
$\pubaux \gets \emptystring$\\
for each $x \in [N]$\\
\nudge for each $b \in [N']$\\
\nudge \nudge if $e_b \in B_i$\\
\nudge\nudge\nudge for $j \in [k]$\\
\nudge\nudge\nudge\nudge $i \gets y_{b,j} \bmod m$\\
\nudge\nudge\nudge\nudge $M_x[i] \gets 1$\\
\nudge $\pubaux \gets \langle\pubaux, M_x \rangle$\\
Return $\pubaux$
}
\caption{Simulator for the proof of Theorem~\ref{thm:bi-ds-prf-priv-ss} }
\label{fig:sim-bi-ds-prf}
\end{figure}

The proof that this provides a good simulation is identical to that
of Theorem~\ref{fig:DS-bigram}. \hfill\qed
\end{proof}


%%%%%%%%%%%%%%%%% GARBLED BF  %%%%%%%%%%%%%%%%%%%%
\subsection{Garbled Bloom Filter}
\begin{figure}[tp]
\centering
\fpage{.8}{
\hpagess{.55}{.45}
{
\algorithmv{$\Rep^H(S)$}\\
$M \gets (\bot)^m$\\
%$K_1,K_2,\ldots, K_k \getsr \calK$\\
for $x \in S$\\
\nudge $\finalshare \gets 0^\lambda$; $\emptyslot \gets -1$\\
\nudge for $j \in \{1,2,\ldots, k\}$\\
\nudge \nudge $h_j \gets H(j,x)$\\
\nudge \nudge if $M[h_j] \neq \bot$ then\\
\nudge \nudge \nudge $\finalshare \gets \finalshare \xor M[h_j]$\\
\nudge \nudge else if $\emptyslot = -1$ then\\
\nudge \nudge \nudge $\emptyslot \gets h_j$\\
\nudge \nudge else\\
\nudge \nudge \nudge $M[h_j] \getsr \bits^\lambda$\\
\nudge \nudge \nudge $\finalshare \gets \finalshare \xor M[h_j]$\\
\nudge $M[\emptyslot] \gets \finalshare \xor x$\\
for $i \in \{1,2,\ldots, m\}$\\
\nudge if $M[i] = \undefined$ then\\
\nudge \nudge  $M[i] \getsr \bits^\lambda$\\
$\pubaux \gets \emptystring$; $\privaux \gets \langle M\rangle$ \mbox{ (if private~$M$)}\\
$\pubaux \gets \langle M \rangle$; $\privaux \gets \emptystring$ \mbox{(if public~$M$)}\\
}
{
\algorithmv{$\Qry^H(\pubaux,\privaux,\qry_x)$}\\
if $\privaux \neq \emptystring$ then $M \gets \privaux$\\
else $M\gets \pubaux$\\
$x' \gets 0^\lambda$\\
for $j \in \{1,2,\dots,k\}$\\
\nudge $h_j \gets H(j,x)$\\
\nudge $x' \gets x' \xor M[h_j]$\\
if $x' =x $ then Return 1\\
Return 0
}
}
\caption{ $\Rep$ and $\Qry$ algorithms for garbled Bloom
  filter $\setprim_{\mathrm{garbled}}$ in the ROM.hash function $H\colon \calK \times
 \elts \to [m]$. The query set is $\calQ=\{\qry_x\colon
  \univ \to \bits\}$ where $\qry_x(S)=1 \Leftrightarrow x \in S$.}
\label{fig:gbf}
\end{figure}


\begin{figure}[tp]
\centering
\hfpagess{.45}{.45}
{
\adversaryv{$A_{\mathrm{ss}}^{\TestOracle,H}(\pubaux)$}\\[1ex]
$M \gets \pubaux$\\
for $\ell=1$ to $\binom{m}{k}$\\
\nudge $i_1,i_2,\ldots,i_k \gets \mathcal{I}_\ell$\\
\nudge $x \gets M[i_1] \xor M[i_2] \xor \cdots \xor M[i_k]$\\
\nudge if  $x \not\in S \wedge \left(\bigwedge_{j=1}^k H(j,x)=i_j \right)$ then \\
\nudge\nudge $a\gets\TestOracle(x)$\\
\nudge\nudge Return $\bot$\\
}
{
\adversaryv{$A_{\mathrm{ow}}^{H}(\pubaux)$}\\[1ex]
$M \gets \pubaux$\\
for $x \in X_1,X_2,\ldots,X_{q-1}$\\
\nudge for $j=1$ to $k$ \\
\nudge \nudge \nudge $i_j \gets H(j,x)$\\
\nudge $x' \gets M[i_1] \xor M[i_2] \xor \cdots \xor M[i_k]$\\
\nudge if $x' = x$ then Return $x$\\
Return~$X_{q}$
}
%{
%\adversaryv{$A^{\TestOracle}(\pubaux)$}\\[1ex]
%$M \gets \pubaux$\\
%for $1 \leq i_1 < i_2 < \cdots < i_k \leq m$\\
%\nudge $x \gets M[i_1] \xor M[i_2] \xor \cdots \xor M[i_k]$\\
%\nudge if $\TestOracle(x)=1$ then Return $\bot$
%}
%\caption{Adversary for Theorem~\ref{thm:xxx}.  \textbf{Left:} public hash case, \textbf{Right:} private hash case.}
\caption{{\bf Left:} Correctness attack for garbled Bloom filters with public~$M$.  The sequence $\mathcal{I}_1,\mathcal{I}_2,\ldots$ is some implicit enumeration of~$k$-tuples of indices over $[m]$.
{\bf Right:} One-wayness attack for garbled Bloom filters with public~$M$.  The sequence $X_1,X_2,\ldots,X_q,$ are the~$q$ most probable points in the support of~$\distr{}{}$ in decreasing order.  }
\label{fig:adv-gbf}
\end{figure}
Dong, Chen and Wen~\cite{dong2013private} introduce a set-membership data
structure called a \emph{garbled Bloom filter} (GBF).   Modulo some implementation
details, a GBF is like a classical Bloom filter, but
rather than storing a bit 1 at the indices determined by $H_j(x)$, the
GBF stores xor-shares of~$x$.  Thus, if $x \in S$, then hashing~$x$
and xoring together the strings stored at the indicated positions
recovers~$x$. We give the pseudocode for the GBF $\Rep$ and $\Qry$
algorithms in Figure~\ref{fig:gbf}.

In~\cite{dong2013private} the GBF is a central piece of a private set-intersection
scheme, in which the client computes a classical BF over its
set~$S_1$, the server computes a GBF over its set~$S_2$, and then an
oblivious transfer protocol is carried out, at the end of which the
client obtains a GBF for $S_1 \cap S_2$ (the server learns nothing).
The authors note that the GBF is a new set-membership data structure
that may be of general interest, so we explore its correctness and
privacy with respect to use case that may or may not make the
representation~$M$ public. The pseudocode in Figure~\ref{fig:gbf}
covers both possibilities.

\heading{Correctness.}
We note that~\cite{dong2013private} provides error-rate analysis, i.e., the
probability of finding a single false-positive in a non-adaptive
attack.  When $\lambda$ is the bit-length of the xor-shares, they
argue that the error-rate is at most $2^{-\lambda}$, roughly because
the xor-shares stored in~$M$ are random strings.  (Note that
  this is independent of~$k,m,n$; although $k>1$ is required for the
  xor shares.)  However, this analysis implicitly assumes that the potential false-positive string~$x$ is fixed
\emph{before}~$M$ is determined.  We will see that this carries over
\tsnote{I think?} to the case in which~$M$ is private (i.e.,
$\pubaux=\emptystring,\privaux=\langle M \rangle$), but when~$M$ is
public things are different.

Consider the adversary described in the left half of Figure~\ref{fig:adv-gbf}.  In one
round of the for-loop, it pics~$k$ positions $i_1,i_2,\ldots,i_k$, and
xors the strings at these positions to get a candidate~$x$.   If $x
\in S$, which the adversary knows in the correctness experiment, then
it moves on to a new set of positions.  If $x \not\in S$ and
$h_{1}(x)=i_1 \wedge h_2(x)=i_2 \wedge \cdots \wedge h_k(x) = i_k$,
then it \emph{must be} that $x$ is a false-positive.   Indeed, note
that the probability of this (in the ROM) is precisely the
false-positive rate of a classical BF using the same $(k,m,n)$ as the GBF.

Now, this adversary will find a false positive, if there is one, but in the worst case it will consider
$\binom{m}{k} \approx m^k$ $k$-tuples of positions.  If both~$m$
and~$k$ are large this is infeasible.  In~\cite{dong2013private} they suggest to
set~$k=\lambda$, and test with $\lambda=80$.  Making 80 hash calls per
set-membership query would be prohibitive in many applications, and a
$2^{-80}$ false-positive rate would be typically considered overkill in
practice.\footnote{Note
that, as described in~\cite{dong2013private}, $\lambda$ must be at least the
bit-length of the longest element $x \in S$. In practice, this could be
  handled with a slight change to the set membership test, by checking
if the $\lambda$-bit shares xor to, say, the $\lambda$-bit truncation
of~$x$.}
Let us consider a practically interesting set of parameters. Say you have a 1000-position
filter, $m=1000$, and a 100-element set, $n=100$,  and $k=4$ hash
functions (a la Squid~\cite{fan2000summary}).  This results in a false-positive rate of
approximately 1\% in a classical BF.  There are roughly $2^{35}$
subsets of four indices to consider, which is reasonable on a
commodity laptop.  Moreover, with $n=100$ the expected
number of trials is roughly $2^{28}$.
Note that the attack is easily extended to find $r>1$ false positives.

We admit that attack is not particularly sophisticated, yet it might
be significantly more efficient than brute force guessing.  When $k,m,n$ are as in the example just given, and $\elts=\bits^{128}$,
this attack will be considerably faster even if the attacker knows that the distribution deviates significantly from uniform.   Note that in the ROM, the order in which $k$-tuples are considered is largely irrelevant, especially when $2^\lambda \gg \binom{m}{k}$.
%Notice,too, that you \emph{cannot} mount it against a standard Bloom filter.

Finally, we observe that a similar version of the correctness attack
works outside of the ROM, say, when we hash via $H(j,x)=F_K(\langle
j,x \rangle)$ and assume~$F_K$ is a secure PRF.  Here,
$\privaux=\langle K \rangle$.  Now,
however, the work switches from offline hash evaluations (i.e., random
oracle calls) to online set-membership (i.e., $\TestOracle$) queries.

In the full version of this paper, we will give a correctness bound
for the \emph{private}-$M$ GBF, i.e., $\pubaux=\emptystring,
\privaux=\langle M \rangle$, in the random-oracle model.  
%
%\begin{theorem}[{\rm Correctness of private-$M$ GBF in the ROM}]\label{thm:gbf-correctness}
%Fix $k,m,n,r,\lambda>0$, and let $\setprim_{\mathrm{gbf}}=(\Rep, \Qry)$ be the private-$M$ garbled Bloom filter. For any adversary~$A$ that makes a total of~$q_T$ queries to the $\Test$ oracle, and $q_R$ queries to the RO, and has time-complexity~$O(t)$,
%\[
%\AdvCorrect{\setprim_{\mathrm{gbf}},r}{A} \leq \mbox{\fixme{}}
%\]
%\end{theorem}

\heading{Privacy. }
We observe immediately that when~$\pubaux=\langle M \rangle$ the GBF cannot be SS-private (in the ROM) because $\privaux=\emptystring$.  In fact, the correctness attack given above suggests a one-wayness attack in the ROM, too; see the right half of Figure~\ref{fig:adv-gbf}.   The naive attack would simply output the most probable element in the support of the distribution $\distr{}{}$ used in the one-wayness experiment to sample~$S$.  But when~$M$ and the hash functions are available to the attacker, it can carry out set-membership tests for itself.  Thus the adversary on the right of Figure~\ref{fig:adv-gbf} tries the~$q-1$ most probable points, in order, halting with its output as soon as the set-membership test is successful.  If none of these points are yield a successful test, then the next most probable point is output.  It is not hard to conclude the following theorem.

\begin{theorem}[{\rm OW-privacy of public-$M$ GBF}]
Fix $k,m,n,r,\lambda>0$, and let $\setprim_{\mathrm{gbf}}=(\Rep, \Qry)$ be the public-$M$ garbled Bloom filter, in the random-oracle model for~$H$.  Then \fixme{This probability might not be correct... verify when less tired.}
\[
\AdvPrivOW{\setprim_{\mathrm{gbf}},\distr{}{}}{A_{\mathrm{ow}}} \geq 1 - \left(1-\frac{n}{2^{\mu}} \right)^{q} \geq 1 - e^{-nq/2^\mu}
\]
 where $\mu = H_\infty(\distr{}{})$ is the pointwise min-entropy of~$\distr{}{}$, and $A_{\mathrm{ow}}$ makes $kq$ random-oracle queries.
\end{theorem}
\noindent
We conjecture that this is the optimal attack on the GBF in this setting.

If instantiated with hash functions $H_j(x) = F_K(\langle j,x \rangle)$ and $\privaux = \langle K \rangle$, the SS-privacy of the GBF follows directly from~Theorem~\ref{thm:priv-ss}.
\begin{theorem}[{\rm SS-privacy of GBF with secret hash functions}]
\label{thm:gbf-prf-privacy}
Fix $k,m,n,r,\lambda>0$ and a function family~$F\colon \calK \times
\bits^* \to [m]$.  Let $\setprim_{\mathrm{gbf\mbox{-}prf}}= (\Rep,
\Qry)$ be the garbled Bloom filter with hash functions
$H_j(x)=F_K(\langle j,x \rangle)$ and $\privaux=\langle K \rangle$.
For any set~$S$, let $\leak(S)=|S|$.  There exists a simulator~$\Sim$
and an adversary~$B$ (making $kn$ queries) such that, for any adversary~$A$
\[
\AdvPrivSS{\setprim_{\mathrm{gbf\mbox{-}prf}},\leak}{A,\Sim} \leq  \AdvPRF{F}{B}\;.
\]
%(Both~$B$ and~$\Sim$ are explicitly constructed in the proof of this theorem.)
\end{theorem}
\begin{proof}
It suffices to give the decomposition of $\Rep$ in to $\Rep_1$ and $\Rep_2$ as required by Theorem~\ref{thm:priv-ss}.
On input a set of distinct elements $S=\{x_1,x_2,\ldots,x_n\}$, algorithm~$\Rep_1$ returns $s_1=\langle 1,x_1 \rangle, s_2=\langle 2,x_1 \rangle, \ldots, s_k\langle k,x_1\rangle, s_{k+1}=\langle 1,x_2\rangle, \ldots,\linebreak s_{2k}=\langle k,x_2\rangle, \ldots ,s_{kn+1}=\langle 1,x_n\rangle, \ldots, s_{kn}=\langle k,x_n \rangle$.  On input $n,F_K(s_1),\ldots,\linebreak F_K(s_{kn})$, algorithm $\Rep_2$ carries out the pseudocode of~$\Rep$ in Figure~\ref{fig:gbf}, making use of $F_K(s_1),\ldots,F_K(s_{kn})$ in the obvious way.  It returns~$M$ as $\pubaux$.\hfill\qed
\end{proof}


\ignore{
\begin{verbatim}
%----- LEFT HERE FOR REMINDERS, AND FOR MENTIONING OPEN PROBLEMS IN INTRO-------------------------------%
\end{verbatim}

\todo{Below are two lists of things that we should show.}

\heading{Correctness. }  Here we give security proofs and attacks with respect to the correctness notions.
\begin{itemize}
\item Show Bloom Filter is correct in the ROM. \jnote{Should follow along the lines
of Theorem~2, but taking into account adversary's oracle queries.} [DONE]
\item correctness security/attacks on the bigram/PRF-based double-hashing construction ($h_j(x) = F_{K1}(x) + j\cdot F_{K2}(x) \bmod m$ where the~$x$ are bigrams of names, etc.)
\item correctness-security/attacks on the bigram/domain-separated PRF construction ($h_j(x)=F_K(\langle j,x \rangle) \bmod m$, or just assume range of~$F$ is $[m]$.)
\item correctness-security/attacks Dong, Chen, Wen ``garbled Bloom filter'' construction

\end{itemize}

\heading{Privacy. }
\begin{itemize}
\item Prove that the basic BF, in the ROM, is private.  \tsnote{Not SS, should be OW}
\item Show that the bigram DS-PRF construction is/isn't SS [DONE]
\item Show that the basic BF DS-PRF construction is SS [DONE]
\item Prove privacy bounds for the constructions from NY \tsnote{Follows from Jon's meta-theorem}

\item Cast Niedermeyer Niedermeyer et al.\ attacks on the bigram/PRF-based double-hashing construction (see their paper) into our formalism.  \tsnote{Note that their attack would allow one to recover \emph{every} name, not just one.}

\item Prove a privacy bound for the bigram/PRF-based double-hashing construction that Niedermeyer et al.\ attacks. I expect that the provable security bound is considerably worse than the min-entropy because of the way the representation is made.  (Essentially, the Hamming weight of the representation is a good estimate of the length of the longest surname in filter.)
\jnote{Maybe tailor leakage function appropriately, i.e., so that it only leaks the number of bigrams?}

\item Attack correctness of Dong, Chen, Wen ``garbled Bloom Filter'' construction when the hash functions are public.\tsnote{I give the attack in the related work section.  Copy it here and flesh it out.}  Prove priv-security privacy of construction when hash functions are secret.  \tsnote{Makes the point that the application setting really matters.}

\item Prove privacy bounds of other suggestions, such as the record-level BF from Durham et al.?  This would be a nice pairing with the Niedermeyer et al.\ results \tsnote{No time.}

\end{itemize}
}
