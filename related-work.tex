Bloom filters are one of the most widely used data structures for set-membership queries. Hbase, a hadoop based NoSql database designed to handle large datasets has an implementation of Bloom filter and counting Bloom filter. Hbase is the open-source implementation of Google's BigTable storage system~\cite{chang2008bigtable}. Stochastic Fair Blue~\cite{feng2001stochastic} uses counting Bloom filter to manage non-responsive TCP traffic. The counting Bloom filters are used as accounting bins to maintain statistics of packets belonging to each bin based on their queue lengths. In Squid~\cite{fan2000summary}, each web proxy server uses a bloom filter(summary cache) corresponding to the set of URL's in its cache to perform membership look-up of incoming URL's. Also, it has bloom filters of its neighboring proxy servers. Reynolds and Vahdat~\cite{reynolds2003efficient} proposed an efficient distributed search engine that can be used to search for files that contain a particular keyword. This search engine maps the keywords of each file into a Bloom filter; a look-up of the keyword in the Bloom filter tells whether the node has files containing that keyword or not. Record linkage is very often required to collect and combine records from different databases. In absence of unique identification number of the records, privacy preserving record linkage(PPRL) is used. Schnell et. al.~\cite{schnell2011novel} proposed Cryptographic Longterm Key to carry out PPRL. They used secretly keyed hash functions to create a Bloom filter for each surname. The surname is broken into bigrams and mapped into the Bloom filter with secret hash functions. 

Niedermeyer et al.~\cite{niedermeyer2014cryptanalysis} showed an attack on a database of German surnames which were stored in secretly hashed Bloom filters, similar to Cryptographic Longterm Key. A Bloom filter that uses $k$ hash functions will have minimum hamming weight of $k$. Using this fact, an adversary can filter out Bloom filters that have hamming weight less than 15. This is an example of how inherent properties of a data structure can be used by an adversary. Crossby and Walach~\cite{crosby2003denial} exploited hash collisions in Squid to increase the average URL load time. They carried out two experiments to show this attack. In experiment 1, around 143K random URL's were requested to the proxy server, whereas in experiment 2, same number of carefully chosen URL's (adaptive queries) that collide with the already present URL's in the hash-table were requested. They observed that the load time of random URL's was less than the chosen URL's, and hence can be used to degrade performance of a proxy server. Whenever there is a collision in a hash table, some amount of extra time is required for collision resolution. In an older paper, Lipton and Naughton~\cite{lipton1993clocked} showed how timing analysis of record insertion in a hash table can help an adversary to adapt and chose elements that take more time to be mapped into the hash table.