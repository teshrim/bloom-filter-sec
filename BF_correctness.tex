%\section{Proof of Theorem~\ref{thm:bf-correctness}}
%\label{sec:thm3_fp}
\begin{proof}[Theorem~\ref{thm:bf-correctness}]
We use a game playing argument, please refer to Figures~\ref{fig:bf-correctness-games1} and~\ref{fig:bf-correctness-games2}. In $\game{0}$, the $\Hash$ does lazy sampling of elements from $[m]$ to mimic a random oracle(RO). For every distinct query, $\Hash$ returns a random value sampled from $[m]$. Here, the adversary $A$, along with $\Rep$ and $\Qry$ are given access to $\Hash$. It can be seen that, $\game{0}$ exactly simulates the correctness game of $\setprim_{\mathrm{Bloom}}$. So, $\AdvCorrect{\setprim_{\mathrm{Bloom}},r}{A} = \Prob{\game{0}(A) = 1}$.

$\game{1}$ is exactly same as $\game{0}$ except the $\Qry$ oracle is replaced by the code of $\Qry$, whereas in $\game{2}$, the $\Test$ oracle returns the hash values back to the adversary along with output of the $\Qry$ oracle. $\game{3}$ on the other hand, returns all the $k$ hash values for any query. This results in adversary getting $(k-1)$ hash values for free as we charge the adversary for a single query. Since $k$ is likely to be very small compared to the number of queries the adversary makes, this would not affect the analysis in any significant manner. Also, in real world, RO will be a hash function; hence the adversary can perform local computations to get the hash values. It can be easily seen that the output of all the games will be same. So, $\Prob{\game{0}(A) = 1} = \Prob{\game{1}(A) = 1} = \Prob{\game{2}(A) = 1} = \Prob{\game{3}(A) = 1}$. 

In $\game{4}$, assuming $A$ does not make any pointless queries, $\Hash$ returns $k$ random values (for each query) sampled from $[m]$. Also, we offload all of $\Test$'s computations to $\Hash$, which now maintains an $\Ans$ table to compute and save answers for each query.  For any query, $\qry$, the $\Test$ oracle returns answer stored at $\Ans[\qry]$. We also introduce the $\bad$ flag in this game. Like in the earlier proofs,  $\bad$ is set to true, if queries indexed by the r-set $\calI$ fail to be false positives, or the other queries are false-positives. $\bad$ in fact does not affect the output of $\Hash$ or the game. So, $\Prob{\game{4}(A) = 1} = \Prob{\game{3}(A) = 1}$. 

$\game{5}$ is exactly same as $\game{4}$, but returns 0, if $\bad$ is set to true. It can be observed that, the total queries made to the $\Hash$ oracle by the adversary is the sum of queries($q_T$) made by the $\Test$ oracle, and adversary's direct queries($q_H$) to the RO. Using analyses and intermediate results of previous proofs, $\Prob{\game{5}(A)=1} = \dfrac{1}{\binom{q_T + q_H}{r}}\Prob{\game{4}(A)=1}$.

For $r=1$, $\game{5}$ exactly simulates the classical Bloom filter. Since, $\Hash$ returns random values for each query, the event of getting a false-positive is independent of the index of the query. Using Kirsch and Mitzenmacher's upper bound on false positive probability of a classical Bloom filter, we have  $\Prob{\game{5}(A)=1} = \left( (1-e^{-kn/m})^k + O(1/n) \right)^r$.

To summarize, 
\[
\AdvCorrect{\setprim_{\mathrm{Bloom}},r}{A} \leq  {\dbinom{q_T + q_H}{r}} \left( (1-e^{-kn/m})^k + O(1/n) \right)^r\,.
\]
which is the bound claimed in the theorem statement.
\begin{figure}[tp]
\fpage{.9}{
\hpagessl{.45}{.5}
{
\underline{\game{0}(A)}\\
$S \getsr A$; $\calC \gets \emptyset$; $\err \gets 0$\\
$(\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
$\bot \getsr A^{\TestOracle}(\pubaux)$\\
if $\err  < r$ then Return 0\\
Return 1\\
%
\oracle{$\TestOracle(\qry_x)$}\\
if $x \in \mathcal{C}$ then Return $\bot$\\
$\calC \gets \calC \cup x$\\
$a \gets \Qry^{\HashOracle}(\pubaux,\privaux, x)$\\
if $a \neq \qry_x(S)$ then \\
\nudge $\err \gets \err + 1$\\
Return~$a$\\
%
\oracle{$\HashOracle(i,\qry_y)$}\\
$v \getsr [m]$\\
if $T[i,y] \neq \undefined$\\
\nudge $v \gets T[i,y]$\\
$T[i,y] \gets v$\\
Ret $v$
}
{
\underline{$\game{1}(A)$}\\
$S \getsr A$; $\calC \gets \emptyset$; $\err \gets 0$\\
$(\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
$\bot \getsr A^{\TestOracle}(\pubaux)$\\
if $\err  < r$ then Return 0\\
Return 1\\
%
\oracle{$\TestOracle(\qry_x)$}\\
if $x \in \mathcal{C}$ then Return $\bot$\\
$\calC \gets \calC \cup x$; $M \gets\pubaux$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets \HashOracle(j, x)$\\
\nudge if $M[h_j] \neq 1$ then Return 0\\
$\err \gets \err + 1$\\
Return 1\\
%
\oracle{$\HashOracle(i,\qry_y)$}\\
$v \getsr [m]$\\
if $T[i,y] \neq \undefined$\\
\nudge $v \gets T[i,y]$\\
$T[i,y] \gets v$\\
Ret $v$
}
}
\fpage{.9}{
\hpagessl{.45}{.5}
{
\underline{$\game{2}(A)$}\\
$S \getsr A$; $\calC \gets \emptyset$; $\err \gets 0$\\
$(\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
$\bot \getsr A^{\TestOracle}(\pubaux)$\\
if $\err  < r$ then Return 0\\
Return 1\\ 
%
\oracle{$\TestOracle(\qry_x)$}\\
if $x \in \mathcal{C}$ then Return $\bot$\\
$\calC \gets \calC \cup x$; $M \gets\pubaux$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets \HashOracle(j, x)$\\
\nudge if $M[h_j] \neq 1$\\
\nudge \nudge Return $(0, (h_1, \ldots, h_j))$\\
$\err \gets \err +1$\\
Return~$(1, (h_1, \ldots, h_{k}) )$\\
%
\oracle{$\HashOracle(i,\qry_y)$}\\
$v \getsr [m]$\\
if $T[i,y] \neq \undefined$\\
\nudge $v \gets T[i,y]$\\
$T[i,y] \gets v$\\
Ret $v$
}
{
\underline{$\game{3}(A)$}\\
$S \getsr A$; $\calC \gets \emptyset$; $\err \gets 0$\\
$(\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
$\bot \getsr A^{\TestOracle}(\pubaux)$\\
if $\err  < r$ then Return 0\\
Return 1\\ 
%
\oracle{$\TestOracle(\qry_x)$}\\
if $x \in \mathcal{C}$ then Return $\bot$\\
$\calC \gets \calC \cup x$; $M \gets\pubaux$\\
$(h_1, \ldots, h_{k}) \gets \HashOracle(x)$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge if $M[h_j] \neq 1$ then \\
\nudge \nudge Return~$(0, (h_1, \ldots, h_{k}) )$\\
$\err \gets \err +1$\\
Return~$(1, (h_1, \ldots, h_{k}) )$\\
%
\oracle{$\HashOracle(\qry_y)$}\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $v_j \getsr [m]$\\
\nudge if $T[j,y] \neq \undefined$\\
\nudge \nudge $v_j \gets T[j,y]$\\
\nudge $T[j,y] \gets v_j$\\
Ret $\left(v_1,\ldots,v_k\right)$
}
}
\caption{Games $\game{0}$-$\game{3}$ for the
proof of Theorem\ref{thm:bf-correctness}.}
\label{fig:bf-correctness-games1}
\end{figure}
\begin{figure}[tp]
\fpage{.9}{
\hpagessl{.45}{.5}
{
\underline{\game{4}(A)\fbox{\game{5}(A)}}\\
$c\gets 0$, $\bad \gets \false$, $\err \gets 0$;  $\calC \gets \emptyset$\\
$S \getsr A$; $\mathcal{I}\getsr [\{1,2,\ldots,q\}]^r$\\
$(\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
$\bot \getsr A^{\TestOracle}(\pubaux)$\\
if $\bad = \true$ then \fbox{Return 0}\\
if $\err  < r$ then Return 0\\
Return 1\\
%
\oracle{$\TestOracle(\qry_x)$}\\
if $x \in \mathcal{C}$ then Return $\bot$\\
$\calC \gets \calC \cup x$\\
if $\Ans[x] \neq \undefined$\\
\nudge $(h_1, \ldots, h_{k}) \gets \HashOracle(x)$\\
Return $\Ans[x]$\\
%
}
{
\oracle{$\HashOracle(\qry_y)$}\\
$c \gets c + 1$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $v_j \getsr [m]$\\
%
$M \gets\pubaux$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge if $M[v_j] \neq 1$ then \\
\nudge \nudge $\Ans[y] \gets (0, (v_1, \ldots, v_{k}) )$\\
\nudge \nudge if $c \in \calI$ then $\bad \gets \true$\\
\nudge \nudge $\Break$\\
if $j < k$ then Return $\left(v_1,\ldots,v_k\right)$\\
if $c \notin \calI$ then $\bad \gets \true$\\
$\err \gets \err +1$\\
$\Ans[y] \gets (1, (v_1, \ldots, v_{k}))$\\
Return $\left(v_1,\ldots,v_k\right)$
}
}
\caption{Games $\game{4}$-$\game{5}$ for the
proof of Theorem\ref{thm:bf-correctness}.}
\label{fig:bf-correctness-games2}
\end{figure}
\hfill\qed
\end{proof}
