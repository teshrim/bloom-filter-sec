\section{(Set-multiplicity) Data Structures}
\def\pub{{\sf pub}}
\def\aux{{\sf aux}}

\heading{Preliminaries. }
When~$\univ$ is a set and $n>0$ is an integer, we let $[\univ]^n$ denote the set of all size-$n$ subsets of~$\univ$. We write $x \getsr \univ$ to denote sampling an element from~$\univ$ and assigning this to~$x$, and we extend this notation to randomized algorithms.  When~$X$ is a string over some alphabet~$\Sigma$, we write $|X|$ for the bitlength of~$X$, relative to some fixed encoding.  When~$X$ is a multiset, we overload the notation so that~$|X|$ is the number of elements in~$X$ (with mutiplicity).

Algorithms may be provided black-box access to one or more oracles, which we write as superscripts, e.g., $F^{O_1,O_2,\ldots}$.  An \emph{adversary} is a randomized algorithm

\heading{Data Structures.}  We being by defining a general primitive that produces a representation of a given multiset, and provides a mechanism to answer a specified collection of questions about that multiset.  Informally, the representation should serve as a good approximation of the multiset, at least with respect to the allowed questions.
\begin{definition} \rm
Fix a non-empty set~$\univ$. A \emph{static data structure} (over universe~$\univ$)
is a tuple $\setprim=(\Sigma,\Gamma,\calS,\calQ,\Rep, \Qry)$ where:
\begin{itemize}
\item $\Sigma$ is the \emph{representation alphabet}
\item $\Gamma$ is the set of possible \emph{query answers}
\item $\calS$ is a set  of multisets over universe~$\univ$
\item $\mathcal{Q}=\{q \colon \mathcal{S} \to \Gamma\}$ is a set of supported \emph{queries}
\item $\Rep \colon \mathcal{S} \to \Sigma^* \times \bits^*$ is a randomized \emph{representation algorithm}, taking as input $S \in \mathcal{S}$, and outputting a \emph{representation} $M \in \Sigma^*$ and some \emph{auxilliary information} $\aux \in \bits^*$
\item $\Qry\colon \Sigma^* \times \bits^* \times \calQ \to \Gamma$ is a deterministic \emph{query-evaluation} algorithm, taking as input $M, \aux, q$, and returns \emph{answer} $a \in \Gamma$.
\end{itemize}
Let $\mathrm{Err}(S,q,M,\aux)$ be a predicate that is true iff $\Qry(M, \aux, q) \neq q(S)$.  Then a data structure
has \emph{error-probability} $\epsilon$, if
$\max_{S,q}\Pr[(M,\aux) \getsr \Rep(S) : \mathrm{Err}(S,q,M,\aux)=1 ] \leq \epsilon$,
where the maximum is over $S \in \mathcal{S}$ and $q \in \mathcal{Q}$.  Relatedly, it has \emph{error-rate} $\tilde{\epsilon}$ if
$\max_{S}\Pr[(M,\aux) \getsr \Rep(S);\, q \getsr \calQ : \mathrm{Err}(S,q,M,\aux)=1] \leq \tilde{\epsilon}$.
\end{definition}

\noindent
The definition can be lifted to the random-oracle model
by giving $\Rep, \Qry$ access to a random oracle. In that case,
the probabilities defining the error-probability and error-rate are also taken over choice of the random oracle.

All of the data structures that we will consider have the property that~$|M|$ does not depend on the coins of~$\Rep$. Thus we assume that~$|M|$ depends only on~$|S|$.  In general this need not be true, but the assumption does not restrict our syntax from capturing natural constructions (e.g., those seen in practice), and it makes it easier to state our security notions.

We will sometimes say that a data structure is $(1-\epsilon)$-correct, meaning it has error-probability~$\epsilon$.  Note that $1-\epsilon$ is a worst-case lower bound on the correctness of the data structure.

\heading{Set-multiplicity Data Structures. }
Our particular focus will be on data structures that support multiplicity queries, of which set-membership queries are a special case.  
\begin{definition} A \emph{set-multipicity data structure} is a data structure with $D=\mathbb{N}$ and where $\calQ=\{q_x \,|\, x \in \univ\}$ where $q_x(S)$ is defined to be the multiplicity of~$x$ in the multiset~$S$.
\end{definition}
%
%\todo{Readdress issue of representation size.  A general statement might be something like `` The \emph{size} of a set-representation is the maximum (bit)length of any~$M$ that can be output by $\Rep$.''  But all of the natural constructions will have representation whose size will not depend on the coins of $\Rep$, i.e. they depend on $|S|$, number of hash functions, desired error rate. }

%Our treatment of $M,\aux$ is not symmetric, since we only count $M$ against the size
%of the set-representation. When we define security
%we may give the attacker $\aux$ but not~$M$, and in that case the set-representation cannot
%trivially make everything part of~$\aux$. 
%\tsnote{Encoding secrets into~$M$ may cause some headaches in the security definitions; we'll see. }
%\tsnote{By the way, I'm coming around to the
%  viewpoint that it is fair to include in the ``size'' of the
%  representation any secret information.  In makes more difficult
%  comparisons to classical lower-bounds (which [NY] makes, incorrectly
% IMO), but it does seem fair to say ``this is how many bits of memory
% you need to allocate to represent this set \emph{securely}.''}

\heading{Examples.}
It is not hard to see Bloom filters are one possible instantiation a set-multiplicity data structure.
Fix an $n \geq 0$, let $\mathcal{S}=[\univ]^n$, and let $\Sigma=\Gamma\bits$.  
Let $\calQ$ be a set of predicates $q_x$, one for each $x \in \univ$,
such that $q_x(S)=1$ iff $x \in S$.  Define algorithm~$\Rep$, with functions $k=k(|S|), m=m(|S|)$ and a description of a hash function family~$\mathcal{H}=\{h \colon \univ \to \{1,2,\ldots,m\}\}$ hardwired into it, to sample hash functions $h_1, \ldots, h_k$ from~$\mathcal{H}$ and then computes an $m$-bit array in the standard way. It sets $\aux = (h_1, \ldots, h_k)$ and $M$ to be the bit array, and returns these.  The algorithm~$\Qry$ is defined so that, on input $(M,\aux,q_x)$, it returns 1 iff $M[h_1(x)]=1 \wedge M[h_2(x)]=1 \wedge \cdots \wedge M[h_k(x)]=1$ holds.
 
We note that, while our measure of error~$\epsilon$ does not distinguish among ``types'' of errors, it also does not preclude instantiations (like the classical Bloom filter) that admit only one type of error, e.g. false-positives.  

A Bloom filter with secret hash functions is captured by appending to~$M$ appropriate encodings of $h_1,h_2,\ldots,h_k$, and setting $\aux=\emptystring$.  Related constructions that use a secret key~$K$, but not for hashing are captured in analogous ways.

The so-called ``garbled Bloom filter'' due to Dong, Chen and Wen~\cite{xxx}, which stores xor-shares of bitstring~$x \in S$ at positions $h_1(x),h_2(x),\ldots,h_k(x)$ in an array, falls within our syntax by letting~$\Sigma=\bits^L$ for a specified integer~$L>0$.  Similarly the cuckoo-hashing construction from NY, which (loosely speaking) stores a hash $g(x)$ at positions determined by $h_1(x),h_2(x),\ldots,h_k(x)$. \tsnote{Check this, I forget the exact details now.}  

Expanding beyond queries that are predicates, consider $\Sigma=\bits^L$ and a scheme that stores $L$-bit counters at each position in an array.  In particular, for each~$x \in S$ the $\Rep$~algorithm increments the counters stored at $h_1(x),h_2(x),\ldots,h_k(x)$, returns the final array of counters as~$M$.  This representation naturally supports a set of queries $\calQ$ where $q_x$ has the semantics ``what is the multiplicity of~$x$ in~$S$.''   Such a construction gives a static version of a counting Bloom filter~\cite{xxx}.  (We will capture dynamic versions, as well as count-min sketches, scalable Bloom filters, etc., in a later section.)

