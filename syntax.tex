\section{Syntax}
\tsnote{Very much a work-in-progress.}
As a first step, let us try to better formalize Bloom filters as a primitive.

\heading{Hash-based (Bloom) filter syntax.}
Fix a nonempty sets $U,\Sigma$ and integers $k,m,n>0$.  Fix a symbol $\bot \not\in U$.  An $(n,k,m)$-filter (over universe~$U$) is a triple  $B=(\mathsc{H},\mathsc{Rep},\mathsc{Qry})$.   
%
The randomized \emph{hash-sampling} algorithm~$\mathsc{H}$ samples a size~$k$ subset~$\mathcal{H} \subset \mathrm{Func}(U,\{0,1,\ldots,m-1\})$.  We write $\mathcal{H} \getsr \mathsc{H}$ for this operation.
%
The deterministic representation algorithm $\mathsc{Rep}: [U]^n \rightarrow \Sigma^m$ takes a set~$S$ of~$n$ elements as input, and outputs representation~$M$ of length~$m$.  (Recall that $[U]^n$ denotes subsets of~$U$ of size~$n$.)
%
The determinisitc query algorithm $\mathsc{Qry}: \Sigma^m \times U \rightarrow \bits$ takes a representation $M$ and an element $x \in U$ and returns a bit.  
%
We assume that both $\mathsc{Rep}$ and $\mathsc{Qry}$ have the following blackbox access to the functions $h_1,h_2,\ldots,h_k \in \mathcal{H}$, which we denote by writing~$\mathcal{H}$ as a superscript.   Thus, we write $M \gets \mathsc{Rep}^{\mathcal{H}}(S)$ and $b \gets \mathsc{Qry}^{\mathcal{H}}(M,x)$ for the execution of the representation and query algorithms, respectively.

For correctness, we demand that for all $\mathcal{H}$ and $S$, and for all $x \in S, \mathsc{Qry}^{\mathcal{H}}(\mathsc{Rep}^{\mathcal{H}}(S),x)=1$.  

\heading{Discusssion.}
This syntax captures classical Bloom filters by setting~$\Sigma=\bits$ and defining $\mathsc{Rep},\mathsc{Qry}$ in the obvious way.  Setting $\Sigma=\bits^{\leq L}$ allows one to store a bitstring of length at most~$L$ at each location. \tsnote{Would let us capture a construction from NY, among other things.}


\heading{Hash-based filters with operations. }
Here we extend the basic Bloom filter syntax to allow for variations on the traditional Bloom filter, e.g. counting Bloom filters.  \tsnote{We should find out what are the important variations! I only know of a few.  None of these require randomness, so I'll continue to formalize everything as deterministic.}\tsnote{“Scaling Bloom filters”, appear to allow the parameter~$m$, below, to vary. Syntax doesn't address this.}\tsnote{This syntax might naturally support count-min sketches, too.}

Let $\mathbb{M}_\mathcal{U}$ be the set of multisets over~$\mathcal{U}$.  We can denote any multiset as $\{(x,\ell) \,|\, x \in \mathcal{U}, \ell \in \mathbb{N}\}$, and for a particular multiset~$S$ we define the multiplicity of~$x$ as $\mu_S(x) = \ell$ where $(x,\ell)\in S$.

An $(k,m)$-filter with operations is a tuple  $B=(\mathsc{H},\mathsc{Rep},\mathsc{Qry}, \mathcal{F})$.  
The set $\mathcal{F}$ is the finite collection of allowable operations.  All operations are of the form 
$f: \mathbb{M}_{\mathcal{U}} \times \mathbb{M}_{\mathcal{U}} \rightarrow \mathbb{M}_{\mathcal{U}} \cup \{\bot\}$.  
%
The deterministic representation algorithm $\mathsc{Rep}: \mathbb{M}_\mathcal{U} \rightarrow \Sigma^m$ takes a multiset~$S$, and outputs representation~$M$ of length~$m$.   The randomized hash-sampling algorithm and deterministic query algorithm is defined as before.

Correctness is defined as follows.  Let $S,T$ be arbitrary multisets and let~$f$ be an arbitrary operation in $\mathcal{F}$.  If $f(S,T) = S'\neq \bot$, then for all $x \in S'$ we demand that $\mathsc{Qry}(\mathsc{Rep}(S'),x)=1$.  \tsnote{might need a stronger condition that this holds for any sequence of operations that do not result in $\bot$.}

Let us see how this syntax captures various kinds of Bloom filters.  First, let $\Sigma = \mathbb{N}$ and define $f_{\mathrm{add}}(S,T)=\{(x,\mu_S(x)+\mu_T(x)) \,|\, x \in \mathcal{U}\}$ and $f_\mathrm{del}(S,T) = \{(x,\min\{0,\mu_S(x)-\mu_T(x)\}) \,|\, x \in \mathcal{U} \}$.  Define $\mathsc{Rep}(S')$ as follows: for each $(x,\ell)\in S'$ and $j\in\{1,2,\ldots,k\}$, set $M[h_j(x)]=\ell$.   Finally, define $\mathsc{Qry}(M,x) = 1 \Leftrightarrow \forall j \in \{1,2,\ldots,k\},\; M[h_j(x)] > 0$.  This allows us to capture counting Bloom filters.

\tsnote{There are more direct ways to formalize counting Bloom filters.  But this less direct way will allow us to capture other kinds ``advanced'' Bloom filters proposed in the literature or (more importantly) used in practice. For example, $f_{\mathrm{setify}}(S,T)=\{(x,1) \,|\, x \in \mathcal{U} \mbox{s.t. } \mu_S(x)>0, \mu_T(x)>0\}$.  On the other hand, we may end up deciding it is overkill... }