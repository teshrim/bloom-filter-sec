\newcommand{\Rep}{\mathsc{Rep}}
\newcommand{\Hash}{\mathsc{Hash}}
\newcommand{\Qry}{\mathsc{Qry}}
\newcommand{\Update}{\mathsc{Up}}
\newcommand{\Init}{\mathsc{Init}}
\newcommand{\Test}{\mathsc{Test}}
\newcommand{\multiset}[1]{\mathbb{M}_{#1}}
\newcommand{\ExpCorrectSecHash}[2]{\mathrm{Exp}^{\mathrm{cor\mbox{-}prv}}_{#1}(#2)}
\newcommand{\ExpCorrectPubHash}[2]{\mathrm{Exp}^{\mathrm{cor\mbox{-}pub}}_{#1}(#2)}
\newcommand{\ExpCorrect}[2]{\mathrm{Exp}^{\mathrm{cor}}_{#1}(#2)}

\newcommand{\ExpFPSecHash}[2]{\mathrm{Exp}^{\mathrm{fp\mbox{-}prv}}_{#1}(#2)}
\newcommand{\ExpFPPubHash}[2]{\mathrm{Exp}^{\mathrm{fp\mbox{-}pub}}_{#1}(#2)}
\newcommand{\ExpFP}[2]{\mathrm{Exp}^{\mathrm{fp}}_{#1}(#2)}

\newcommand{\QryOracle}{\mathsf{Query}}
\newcommand{\UpdateOracle}{\mathsf{Update}}
\newcommand{\HashOracle}{\mathsf{Hash}}

\section{Hash-based Filters}
\heading{Preliminaries.}
When~$U$ is a set and $n>0$ is an integer, we let $[U]^n$ denote the set of all size-$n$ subsets of~$U$.  We let $\multiset{U}$ denote the set of all finite multisets of~$U$.  We can denote any multiset~$S$ as $\{(x,\ell) \,|\, x \in U, \ell > 0\}$ where each~$x$ appears exactly once, and each~$\ell$ is an integer.  We define the multiplicity of~$x$ as $\mu_S(x) = \ell$.  We write $|S|= \sum_{(x,\ell)\in S}\mu_S(x)$, and let $\multiset{U,n}$ denote the set of multisets~$S$ where $|S|=n$. 

We write $x \getsr U$ to denote sampling an element from~$U$ and assigning this to~$x$, and we extend this notation to randomized algorithms.

\heading{Syntax.}
Fix a nonempty sets $U,\Sigma$ and integers $k,m,n>0$.  Fix a symbol $\bot \not\in U$.  An $(n,k,m)$-filter (over universe~$U$) is a tuple  $B=(\Hash,\Rep,\Qry)$.   
%
The randomized \emph{hash-sampling} algorithm~$\Hash$ samples a size~$k$ family of functions~$\mathcal{H}=\{h_1,h_2,\ldots,h_k\}$ where each $h_i \in  \mathrm{Func}(U,\{0,1,\ldots,m-1\})$.  We write $\mathcal{H} \getsr \Hash$ for this operation.
%
The deterministic representation algorithm $\Rep\colon [U]^n \rightarrow \Sigma^m$ takes a set~$S$ of~$n$ elements as input, and outputs representation~$M$ of length~$m$.
%
The determinisitc query algorithm $\Qry\colon \Sigma^m \times U \rightarrow \bits$ takes a representation $M$ and an element $x \in U$ and returns a bit.  
%
We assume that both $\Rep$ and $\Qry$ have the following blackbox access to the functions $h_1,h_2,\ldots,h_k \in \mathcal{H}$.
%which we denote by writing~$\mathcal{H}$ as a superscript.   
%Thus, we write $M \gets \Rep^{\mathcal{H}}(S)$ and $b \gets \Qry^{\mathcal{H}}(M,x)$ for the execution of the representation and query algorithms, respectively.
%
%We write $M \gets \Rep(S)$ and $b \gets \Qry(M,x)$ for the execution of the representation and query algorithms, respectively.
For correctness, we demand that for all~$S$ of size~$n$, we have that for all $x \in S, \Prob{\Qry(\Rep(S),x)=1}=1$, where the probability is over the coins of $\Hash$.  


%\heading{Discusssion.}
This syntax captures classical Bloom filters by setting~$\Sigma=\bits$,  and defining $\Rep,\Qry$ in the obvious way.  Setting $\Sigma=\bits^{\leq L}$ allows one to store a bitstring of length at most~$L$ at each location. \tsnote{Would let us capture a construction from NY, among other things.}  We note that even though this would allow for the storage of counters (say) at each filter location, our restriction that~$\Qry$ returns a bit does not capture functionality typically demanded of Bloom filters that employ counters, e.g., returning a counter value. (One could, however, have $\Qry$ compute an arbitrary, fixed predicate.  For example, ``has~$x$ been seen at least 5 times?''.)  
Our syntax also does not capture filters that are mutable, that is, whose representation may change over time. 
On the other hand, we can state a simple correctness condition for these kinds of filters; this will not be true when we further generalize to capture, properly, counters and mutability.

\heading{FP-security of hash-based filters.} \tsnote{Write text.  Note that it makes sense to consider soundness both in the public and private hash setting.  NY give it in the private hash setting (sort of); but, intuitively, it should be hard to find false-positives even if you know that MD5 or SHA-x are the hash functions  It might be interesting to run some experiments, e.g. set up a bloom filter of URLs or IP/port information, and then open up a network tap and see how many false positives we observe.} 

\begin{figure}
\centering
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPSecHash{S,B}{A}$}\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Init^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0\\

\medskip
\experimentv{$\ExpFPPubHash{S,B}{A}$}\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Init^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle,\HashOracle}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
if $M = \bot$ then Ret $\bot$\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
\caption{False-positive security (soundness) for an $(n,k,m)$-filter~$B$.  {\bf Top:} when the hash functions are private.  {\bf Bottom:} when the hash functions are public.}
\label{fig:fp-filter}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Mutuable hash-based filters}
Here we extend the basic Bloom filter syntax to allow for variations on the traditional Bloom filter, e.g. counting Bloom filters~\cite{xxx}, spectral Bloom filters~\cite{xxx}, count-min sketches~\cite{xxx}, stable Bloom filters~\cite{xxx}, etc.   Before giving it, let us briefly describe what is formalized.  Our syntax captures settings in which there is some (potentially empty) initial set~$S$, whose representation~$M$ may undergo updates over time.  Effectively, this allows for expansion of~$S$ to a larger set, or even a multiset, as new elements ``arrive''.    The update algorithm is responsible for altering the current representation.  We allow it to take in a string that encodes inputs needed to carry out the updating.  For example, counting Bloom filters may receive update strings that encode $(x,c)$ where $x \in U$ is the element whose representation should be incremented, and $c \in \mathbb{N}$ is the amount of the increment.  Network applications, such as looking for heavy-hitters across TCP/IP streams seen by a router, may have $x = (\mathrm{IP_{src}},\mathrm{IP_{dst}})$, the source and destintation address of a packet, and~$c$ the number of bytes in the packet payload.  When necessary we will specify what is encoded in the update string, but will assume some implicit and fixed encoding scheme.  Note that our syntax allows for randomized updating.  This accommodates stable Bloom filters, for example, which has a randomized ``forgetting'' feature as part of its update.

\heading{Syntax. }
Fix nonempty sets $U,\Sigma$ and integers $k,m_1,m_2,n>0$ with $m_1 \leq m_2$.  Fix a symbol $\bot \not\in U$.  An $(n,k,[m_1,m_2])$-filter (over universe~$U$) is a tuple  $B=(\Hash,\Init,\Qry,\Update, \Test)$.   
%
The randomized \emph{hash-sampling} algorithm~$\Hash$ samples a size~$k$ family of functions~$\mathcal{H}=\{h_1,h_2,\ldots,h_k\}$ where each $h_i \in  \mathrm{Func}(U,\{0,1,\ldots,m_2-1\})$.  We write $\mathcal{H} \getsr \Hash$ for this operation. 
%
The deterministic \emph{initial-representation} algorithm $\Init\colon \multiset{U,n} \rightarrow \left(\bigcup_{m=m_1}^{m_2}\Sigma^m\right)$ takes a multiset~$S$ of size~$n$ as input, and outputs representation~$M$ of length~$m_1 \leq m \leq m_2$.
%
The determinisitc query algorithm $\Qry\colon \left(\bigcup_{m=m_1}^{m_2}\Sigma^m \right)\times U \rightarrow \bits^*$ takes a representation $M$ and an element $x \in U$ and returns a bitstring.  
%
The randomized \emph{update} algorithm $\Update\colon \left(\bigcup_{m=m_1}^{m_2}\Sigma^m \right)\times \bits^* \rightarrow \left(\bigcup_{m=m_1}^{m_2}\Sigma^m \right) \cup \{\bot\}$ takes a representation and an update string, and returns an updated representation or the distinguished symbol~$\bot$.  
%
The deterministic \emph{test} algorithm $\Test \colon \multiset{U}\times \left(\bigcup_{m=m_1}^{m_2}\Sigma^m \right)\cup\{\bot\} \times U \rightarrow \bits$ takes a multiset~$S$, a representation~$M$ and an element~$x \in U$ and returns a bit.
%
%We assume that all $\Init,\Qry,\Update,\Test$ all have blackbox access to the functions $h_1,h_2,\ldots,h_k \in \mathcal{H}$, which we denote by writing~$\mathcal{H}$ as a superscript.   

\heading{Correctness. } The kind of filters we capture, here, can have \emph{two-sided} error.  That is, they may result in false-negatives as well as false-positives.  We captures two versions of correctness in Figure~\ref{fig:correctness-mutable}, corresponding to whether or not the adversary is given access to the hash functions used to create and update the multiset representation.

\begin{figure}
\centering
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpCorrectSecHash{S,B}{A}$}\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Init^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle,\UpdateOracle}(S)$\\
if $\Test^{\HashOracle}(S,M,x) \neq 1$ then Ret 1\\
Ret 0\\

\medskip
\experimentv{$\ExpCorrectPubHash{S,B}{A}$}\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Init^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle,\UpdateOracle,\HashOracle}(S)$\\
if $\Test^{\HashOracle}(S,M,x) \neq 1$ then Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
if $M = \bot$ then Ret $\bot$\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\UpdateOracle(\sigma)$}\\
if $M = \bot$ then Ret $\bot$ \\
$S \gets S \uplus \{\sigma\}$\\
$M \getsr \Update^{\HashOracle}(M,\sigma)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
\caption{Trying to define correctness for an $(n,k,[m_1,m_2])$-filter~$B$.}
\label{fig:correctness-mutable}
\end{figure}


\heading{Soundness for mutable hash-based filters. } \tsnote{To do.  Same comments as for the simple case, only it's more complicated here what it means to violate soundness.}


\if{0}
\heading{Multiset-oriented hash-based filters. }
\tsnote{Commented out, but in the source: an alternative way to formalize mutable hash-based filters.  This way directly address the inputs as multisets, instead of starting with a set and then updating the represenation a step at a time.  Not sure which is cleaner and more easily applied to real problems, yet.}

Let $\mathbb{M}_\mathcal{U}$ be the set of multisets over~$\mathcal{U}$.  We can denote any multiset as $\{(x,\ell) \,|\, x \in \mathcal{U}, \ell \in \mathbb{N}\}$, and for a particular multiset~$S$ we define the multiplicity of~$x$ as $\mu_S(x) = \ell$ where $(x,\ell)\in S$.

An $(n,k,[m_1,m_2])$-filter with operations is a tuple  $B=(\Hash,\Rep,\Qry, \mathcal{F})$.  
The set $\mathcal{F}$ is the finite collection of allowable operations.  All operations are of the form 
$f: \mathbb{M}_{\mathcal{U}} \times \mathbb{M}_{\mathcal{U}} \rightarrow \mathbb{M}_{\mathcal{U}} \cup \{\bot\}$.  
%
The deterministic representation algorithm $\Rep\colon \mathbb{M}_\mathcal{U} \rightarrow \bigcup_{m=m_1}^{m_2}\Sigma^m$ takes a multiset~$S$, and outputs representation~$M$ of length~$m_1 \leq m \leq m_2$, or the distinguished symbol~$\bot$.  We assume that if the multiset~$S=\{(x_1,\ell_1),(x_2,\ell_2),\ldots,(x_t,\ell_t)\}$ is such that $n < \sum_{i=1}^t \ell_i$ then $\Rep(S)=\bot$.
%
The randomized hash-sampling algorithm~$\Hash$ is as before.
%
The determinisitic query algorithm $\Qry$... \tsnote{Not sure how to define this!  See my comment, below...}

%Correctness is defined as follows.  Let $S,T$ be arbitrary multisets and let~$f$ be an arbitrary operation in $\mathcal{F}$.  If $f(S,T) = S'\neq \bot$, then for all $x \in S'$ we demand that $\Qry(\Rep(S'),x)=1$.  \tsnote{might need a stronger condition that this holds for any sequence of operations that do not result in $\bot$.}

Let us see how this syntax captures various kinds of Bloom filters.  First, let $\Sigma = \mathbb{N}$ and define $f_{\mathrm{add}}(S,T)=\{(x,\mu_S(x)+\mu_T(x)) \,|\, x \in \mathcal{U}\}$ and $f_\mathrm{del}(S,T) = \{(x,\min\{0,\mu_S(x)-\mu_T(x)\}) \,|\, x \in \mathcal{U} \}$.  Define $\Rep(S')$ as follows: for each $(x,\ell)\in S'$ and $j\in\{1,2,\ldots,k\}$, set $M[h_j(x)]=\ell$.   Finally, define $\Qry(M,x) = 1 \Leftrightarrow \forall j \in \{1,2,\ldots,k\},\; M[h_j(x)] > 0$.  This allows us to capture counting Bloom filters. \tsnote{Does it?  Acutally, you might want $\Qry(M,x)$ to return a number, i.e., a counter value.  How do you define correctness then?}

\tsnote{There are more direct ways to formalize counting Bloom filters, like the syntax above.  But this less direct way will allow us to capture other kinds ``advanced'' Bloom filters proposed in the literature or (more importantly) used in practice. For example, $f_{\mathrm{setify}}(S,T)=\{(x,1) \,|\, x \in \mathcal{U} \mbox{s.t. } \mu_S(x)>0, \mu_T(x)>0\}$.  On the other hand, we may end up deciding it is overkill... }
\fi