\section{Hash-based Filters}
\heading{Preliminaries.}
When~$U$ is a set and $n>0$ is an integer, we let $[U]^n$ denote the set of all size-$n$ subsets of~$U$.  We let $\multiset{U}$ denote the set of all finite multisets of~$U$.  We can denote any multiset~$S$ as $\{(x,\ell) \,|\, x \in U, \ell > 0\}$ where each~$x$ appears exactly once, and each~$\ell$ is an integer.  We define the multiplicity of~$x$ as $\mu_S(x) = \ell$.  We write $|S|= \sum_{(x,\ell)\in S}\mu_S(x)$, and let $\multiset{U,n}$ denote the set of multisets~$S$ where $|S|=n$.   The notation $S \uplus \{x\}$ denotes multiset union.

We write $x \getsr U$ to denote sampling an element from~$U$ and assigning this to~$x$, and we extend this notation to randomized algorithms.

\heading{Syntax.}
Fix a nonempty sets $U,\Sigma$ and integers $k,m,n>0$.  Fix a symbol $\bot \not\in U$.  An $(n,k,m)$-filter (over universe~$U$) is a tuple  $B=(\Hash,\Rep,\Qry)$.   
%
The randomized \emph{hash-sampling} algorithm~$\Hash$ samples a size~$k$ family of functions~$\mathcal{H}=\{h_1,h_2,\ldots,h_k\}$ where each $h_i \in  \mathrm{Func}(U,\{0,1,\ldots,m-1\})$.  We write $\mathcal{H} \getsr \Hash$ for this operation.
%
The deterministic representation algorithm $\Rep\colon [U]^n \rightarrow \Sigma^m$ takes a set~$S$ of~$n$ elements as input, and outputs representation~$M$ of length~$m$.
%
The determinisitc query algorithm $\Qry\colon \Sigma^m \times U \rightarrow \bits$ takes a representation $M$ and an element $x \in U$ and returns a bit.  
%
We assume that both $\Rep$ and $\Qry$ have the following blackbox access to the functions $h_1,h_2,\ldots,h_k \in \mathcal{H}$.
%which we denote by writing~$\mathcal{H}$ as a superscript.   
%Thus, we write $M \gets \Rep^{\mathcal{H}}(S)$ and $b \gets \Qry^{\mathcal{H}}(M,x)$ for the execution of the representation and query algorithms, respectively.
%
%We write $M \gets \Rep(S)$ and $b \gets \Qry(M,x)$ for the execution of the representation and query algorithms, respectively.
For correctness, we demand that for all~$S$ of size~$n$, we have that for all $x \in S, \Prob{\Qry(\Rep(S),x)=1}=1$, where the probability is over the coins of $\Hash$.  


%\heading{Discusssion.}
This syntax captures classical Bloom filters by setting~$\Sigma=\bits$,  and defining $\Rep,\Qry$ in the obvious way.  Setting $\Sigma=\bits^{\leq L}$ allows one to store a bitstring of length at most~$L$ at each location. \tsnote{Would let us capture a construction from NY, among other things.}  We note that even though this would allow for the storage of counters (say) at each filter location, our restriction that~$\Qry$ returns a bit does not capture functionality typically demanded of Bloom filters that employ counters, e.g., returning a counter value. (One could, however, have $\Qry$ compute an arbitrary, fixed predicate.  For example, ``has~$x$ been seen at least 5 times?''.)  
Our syntax also does not capture filters that are mutable, that is, whose representation may change over time. 
On the other hand, we can state a simple correctness condition for these kinds of filters; this will not be true when we further generalize to capture, properly, counters and mutability.

\heading{FP-security of hash-based filters.} \tsnote{NY give it in the private hash setting (sort of); but, intuitively, it should be hard to find false-positives even if you know that MD5 or SHA-x are the hash functions.  Not totally sure how to capture this intuition nicely.} 

\begin{figure}
\centering
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPSecHash{S,B}{A}$}\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Init^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPPubHashBB{S,B}{A}$}\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Init^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle,\HashOracle}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPPubHash{S,B}{A}$}\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Init^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}(S,\{h_1,h_2,\ldots,h_k\})$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
\caption{False-positive security (soundness) for an $(n,k,m)$-filter~$B$ with private hash functions (top), black-box queriable hash functions (middle), and public hash functions (bottom). }
\label{fig:fp-filter}
\end{figure}


\tsnote{It might be interesting to run some experiments, e.g. set up a bloom filter of URLs or IP/port information, and then open up a network tap and see how many false positives we observe.  I quite like the idea of empirically supported/driven crypto.} 

\heading{Privacy of hash-based filters.} \tsnote{This is wide open.  Privacy of~$S$?  Privacy of~$M$?  (The latter may or may not imply the former, depending on how we define things.)  Under what assumptions on~$S$ --~min-entropy, computational unguessability, other? Do we want to allow for explicit side information/precomputation? We want something that captures realistic scenarios.}

\begin{figure}
\centering
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpPrivSecHash{S,B}{A}$}\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Init^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}()$\\
if $x\in S$ then Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpPrivPubHashBB{S,B}{A}$}\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Init^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle,\HashOracle}()$\\
if $x\in S$ then Ret 1\\
Ret 0\\
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpPrivPubHash{S,B}{A}$}\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Init^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}(\{h_1,h_2,\ldots,h_k\})$\\
if $x\in S$ then Ret 1\\
Ret 0\\
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
\caption{Set-privacy for an $(n,k,m)$-filter~$B$ for private (top), black-box queriable (middle),  and public (bottom) hash functions. \textcolor{cyan}{Revisit when the FP notion settles out.}}
\label{fig:fp-filter}
\end{figure}