\section{Hash-based Filters}
\heading{Preliminaries.}
When~$U$ is a set and $n>0$ is an integer, we let $[U]^n$ denote the set of all size-$n$ subsets of~$U$.  
We write $x \getsr U$ to denote sampling an element from~$U$ and assigning this to~$x$, and we extend this notation to randomized algorithms.

\heading{Syntax.}
Fix a nonempty sets $U,\Sigma$ and integers $k,m,n>0$.  Fix a symbol $\bot \not\in U$.  An $(n,k,m)$-filter (over universe~$U$) is a tuple  $B=(\Hash,\Rep,\Qry)$.   
%
The randomized \emph{hash-sampling} algorithm~$\Hash$ samples a size~$k$ family of functions~$\mathcal{H}=\{h_1,h_2,\ldots,h_k\}$ where each $h_i \in  \mathrm{Func}(U,\{0,1,\ldots,m-1\})$.  We write $\mathcal{H} \getsr \Hash$ for this operation.
%
The deterministic representation algorithm $\Rep\colon [U]^n \rightarrow \Sigma^m$ takes a set~$S$ of~$n$ elements as input, and outputs representation~$M$ of length~$m$.
%
The determinisitc query algorithm $\Qry\colon \Sigma^m \times U \rightarrow \bits$ takes a representation $M$ and an element $x \in U$ and returns a bit.  
%
We assume that both $\Rep$ and $\Qry$ have the following blackbox access to the functions $h_1,h_2,\ldots,h_k \in \mathcal{H}$.
%which we denote by writing~$\mathcal{H}$ as a superscript.   
%Thus, we write $M \gets \Rep^{\mathcal{H}}(S)$ and $b \gets \Qry^{\mathcal{H}}(M,x)$ for the execution of the representation and query algorithms, respectively.
%
%We write $M \gets \Rep(S)$ and $b \gets \Qry(M,x)$ for the execution of the representation and query algorithms, respectively.
For correctness, we demand that for all~$S$ of size~$n$, we have that for all $x \in S, \Prob{\Qry(\Rep(S),x)=1}=1$, where the probability is over the coins of $\Hash$.  


%\heading{Discusssion.}
This syntax captures classical Bloom filters by setting~$\Sigma=\bits$,  and defining $\Rep,\Qry$ in the obvious way.  Setting $\Sigma=\bits^{\leq L}$ allows one to store a bitstring of length at most~$L$ at each location. \tsnote{Would let us capture a construction from NY, among other things.}  We note that even though this would allow for the storage of counters (say) at each filter location, our restriction that~$\Qry$ returns a bit does not capture functionality typically demanded of Bloom filters that employ counters, e.g., returning a counter value. (One could, however, have $\Qry$ compute an arbitrary, fixed predicate.  For example, ``has~$x$ been seen at least 5 times?''.)  
Our syntax also does not capture filters that are mutable, that is, whose representation may change over time. 
On the other hand, we can state a simple correctness condition for these kinds of filters; this will not be true when we further generalize to capture, properly, counters and mutability.

\heading{FP-security of hash-based filters.} \tsnote{NY give it in the private hash setting (sort of); but, intuitively, it should be hard to find false-positives even if you know that MD5 or SHA-x are the hash functions.  Not totally sure how to capture this intuition nicely.} 
The traditional notion of soundness for a Bloom filter captures the difficulty of finding false-positives when the attacker is non-adaptive.  Following NY, we consider soundness against adaptive adversaries.  But we further generalize to allow for settings in which the attacker may have some a priori knowledge about the contents of~$S$. (The Niedermaier et al.~\cite{xxx} attacks, for example, exploit knowledge about the distribution of German last names.)   In particular, our notions take as input an explicit distribution $\distr{U}{n}$ over $[U]^n$.   

In Figure~\ref{fig:fp-filter} we give three distinct notions, characterized by what access the adversary has to the underlying hash functions used by the filter.  In the top notion, the hash functions are secret.  This is the setting addressed by NY, and it capture applications in which the ``hash functions'' are (say) secretly keyed PRFs, and in which no explicit, external interface to these is surfaced.  
%
The bottom notion considers the case that the full code of the hash functions is known to the attacker.  This is the case, for example, when attacking the Bloom filters used in the Squid proxy~\cite{xxx}.
%
The middle notion is a compromise: it makes the hash functions public, but assumes that the adversary only accesses them in a black-box manner.  That is, the adversary does not exploit structural features of the hash functions in its attack.  This notion makes it easy to track the query complexity of an attack. 

For each experiment, we define an associated advantage notion.  Namely, given an $(n,k,m)$-filter~$B=(\Hash,\Rep,\Qry)$, distribution~$\distr{U}{n}$ and adversary~$A$, we define:
\begin{align*}
\AdvFPSecHash{B}{\distr{U}{n},A} &= \Prob{\ExpFPSecHash{B}{\distr{U}{n},A}} \\
\AdvFPPubHashBB{B}{\distr{U}{n},A} &= \Prob{\ExpFPPubHashBB{B}{\distr{U}{n},A}} \\
\AdvFPSecHash{B}{\distr{U}{n},A} &= \Prob{\ExpFPPubHash{B}{\distr{U}{n},A}}
\end{align*}
The probabilities are over the sampling of the set~$S$ and the hash functions $h_1,h_2,\ldots,h_k$, as well as the coins of the adversary.   In all experiments, we track time-complexity~$t$ of~$A$, as well as the number of set-membership ($\QryOracle$ oracle) queries~$q_{\mathrm{sm}}$ that it makes.   In the second, we also track the number of hash-queries $q_{\mathrm{h}}$ that the adversary makes.


\begin{figure}
\centering
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPSecHash{B}{\distr{U}{n},A}$}\\
$S \getsr \distr{U}{n}$\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPPubHashBB{B}{\distr{U}{n}, A}$}\\
$S \getsr \distr{U}{n}$\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle,\HashOracle}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPPubHash{B}{\distr{U}{n}, A}$}\\
$S \getsr \distr{U}{n}$\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}(S,\{h_1,h_2,\ldots,h_k\})$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
\caption{False-positive security (soundness) for an $(n,k,m)$-filter~$B$ with private hash functions (top), black-box queriable hash functions (middle), and public hash functions (bottom).  }
\label{fig:fp-filter}
\end{figure}


%%%%
% \if{0}
% \begin{figure}
% \centering
% \fpage{.6}{
% \hpagess{.6}{.35}
% {
% \experimentv{$\ExpFPSecHash{S,B}{A}$}\\
% $ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
% $M \gets \Rep^{\HashOracle}(S)$\\
% $x \getsr A^{\QryOracle}(S)$\\
% if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
% \nudge Ret 1\\
% Ret 0
% }
% %
% {
% \oracle{$\QryOracle(x)$}\\
% Ret $\Qry^{\HashOracle}(M,x)$\\

% \medskip
% \oracle{$\HashOracle(i,x)$}\\
% Ret $h_i(x)$\\
% }
% }
% %%%%%%%
% \fpage{.6}{
% \hpagess{.6}{.35}
% {
% \experimentv{$\ExpFPPubHashBB{S,B}{A}$}\\
% $ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
% $M \gets \Rep^{\HashOracle}(S)$\\
% $x \getsr A^{\QryOracle,\HashOracle}(S)$\\
% if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
% \nudge Ret 1\\
% Ret 0
% }
% %
% {
% \oracle{$\QryOracle(x)$}\\
% Ret $\Qry^{\HashOracle}(M,x)$\\

% \medskip
% \oracle{$\HashOracle(i,x)$}\\
% Ret $h_i(x)$\\
% }
% }
% %%%%%%%
% \fpage{.6}{
% \hpagess{.6}{.35}
% {
% \experimentv{$\ExpFPPubHash{S,B}{A}$}\\
% $ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
% $M \gets \Rep^{\HashOracle}(S)$\\
% $x \getsr A^{\QryOracle}(S,\{h_1,h_2,\ldots,h_k\})$\\
% if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
% \nudge Ret 1\\
% Ret 0
% }
% %
% {
% \oracle{$\QryOracle(x)$}\\
% Ret $\Qry^{\HashOracle}(M,x)$\\

% \medskip
% \oracle{$\HashOracle(i,x)$}\\
% Ret $h_i(x)$\\
% }
% }
% \caption{False-positive security (soundness) for an $(n,k,m)$-filter~$B$ with private hash functions (top), black-box queriable hash functions (middle), and public hash functions (bottom). }
% \label{fig:fp-filter}
% \end{figure}
%\fi
%%%%%



\heading{Privacy of hash-based filters.} \tsnote{This is wide open.  Privacy of~$S$?  Privacy of~$M$?  (The latter may or may not imply the former, depending on how we define things.)  Under what assumptions on~$S$ --~min-entropy, computational unguessability, other? Do we want to allow for explicit side information/precomputation? We want something that captures realistic scenarios.}

\begin{figure}
\centering
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpPrivSecHash{B}{\distr{U}{n}, A}$}\\
$S \getsr \distr{U}{n}$\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}()$\\
if $x\in S$ then Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpPrivPubHashBB{B}{\distr{U}{n}, A}$}\\
$ S \getsr \distr{U}{n}$\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle,\HashOracle}()$\\
if $x\in S$ then Ret 1\\
Ret 0\\
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpPrivPubHash{B}{\distr{U}{n}, A}$}\\
$ S \getsr \distr{U}{n}$\\
$ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
$M \gets \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}(\{h_1,h_2,\ldots,h_k\})$\\
if $x\in S$ then Ret 1\\
Ret 0\\
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
\caption{Set-privacy for an $(n,k,m)$-filter~$B$ for private (top), black-box queriable (middle),  and public (bottom) hash functions. \textcolor{cyan}{Revisit when the FP notion settles out.}}
\label{fig:fp-filter}
\end{figure}

\heading{Security in multiple-server settings. }  In this section, we consider security notions for settings in which there may be multiple servers, each holding a filter representation of a set.  To allow for each server to embed server-specific information into its representation, we abstract the servers as $B_1,B_2,\ldots,B_\ell$ where each $B_i=(\Hash_i,\Rep_i,\Qry_i)$ is an $(n,k,m)$-filter.  \tsnote{Still some kinks to be ironed out though.  The current notions sample fresh hash functions for each server.  But in (say) the Squid setting, the same hash functions are used across all Squid instances... maybe it suffices, for that setting, to say that the $\Hash_i$ are all the same, and each simply returns a fixed set of~$k$ hash functions (i.e., deterministic).}

\begin{figure}
\centering
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPSecHash{B_1,B_2,\ldots,B_\ell}{\distr{U}{n}, A}$}\\
$\mathcal{C} \gets \emptyset$\\
for $i=1$ to $\ell$\\
\nudge $S_i \getsr \distr{U}{n}$\\
\nudge $ \mathcal{H}_i \gets \{h^i_1,h^i_2,\ldots,h^i_k\} \getsr \Hash_i$\\
\nudge $M_i \gets \Rep_i^{\HashOracle(i,\cdot,\cdot)}(S_i)$\\
$(i,x) \getsr A^{\QryOracle,\CorruptOracle}(\{S_i\}_{i=1}^{\ell})$\\
if $i \not\in \mathcal{C} \wedge \Qry_i^{\HashOracle(i,\cdot,\cdot)}(M_i,x)=1$ then \\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(i,x)$}\\
Ret $\Qry_i^{\HashOracle}(M_i,x)$\\

\medskip
\oracle{$\HashOracle(i,j,x)$}\\
Ret $h^i_j(x)$\\

\medskip
\oracle{$\CorruptOracle(i,x)$}\\
$\mathcal{C} \gets \mathcal{C} \cup \{i\}$\\
Ret $M_i,\mathcal{H}_i$\\
}
}
%%%%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPPubHashBB{B_1,B_2,\ldots, B_\ell}{\distr{U}{n}, A}$}\\
$\mathcal{C} \gets \emptyset$\\
for $i=1$ to $\ell$\\
\nudge $S_i \getsr \distr{U}{n}$\\
\nudge $ \{h^i_1,h^i_2,\ldots,h^i_k\} \getsr \Hash_i$\\
\nudge $M_i \gets \Rep_i^{\HashOracle(i,\cdot,\cdot)}(S_i)$\\
$(i,x) \getsr A^{\QryOracle,\HashOracle,\CorruptOracle}(\{S_i\}_{i=1}^{\ell})$\\
if $i \not\in \mathcal{C} \wedge \Qry_i^{\HashOracle(i,\cdot,\cdot)}(M_i,x)=1$ then \\
\nudge Ret 1\\ 
Ret 0
}
%
{
\oracle{$\QryOracle(i,x)$}\\
Ret $\Qry^{\HashOracle}(M_i,x)$\\

\medskip
\oracle{$\HashOracle(i,j,x)$}\\
Ret $h^i_j(x)$\\

\medskip
\oracle{$\CorruptOracle(i,x)$}\\
$\mathcal{C} \gets \mathcal{C} \cup \{i\}$\\
Ret $M_i$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPPubHash{B_1,B_2,\ldots,B_\ell}{\distr{U}{n}, A}$}\\
$\mathcal{C} \gets \emptyset$\\
for $i=1$ to $\ell$\\
\nudge $S_i \getsr \distr{U}{n}$\\
\nudge $ \mathcal{H}_i \gets \{h^i_1,h^i_2,\ldots,h^i_k\} \getsr \Hash_i$\\
\nudge $M_i \gets \Rep_i^{\HashOracle(i,\cdot,\cdot)}(S_i)$\\
$(i,x) \getsr A^{\QryOracle,\CorruptOracle}(\{S_i\}_{i=1}^{\ell},\{\mathcal{H}_i\}_{i=1}^{\ell})$\\
if $i \not\in \mathcal{C} \wedge \Qry_i^{\HashOracle(i,\cdot,\cdot)}(M_i,x)=1$ then \\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(i,x)$}\\
Ret $\Qry^{\HashOracle}(M_i,x)$\\

\medskip
\oracle{$\HashOracle(i,j,x)$}\\
Ret $h^i_j(x)$\\

\medskip
\oracle{$\CorruptOracle(i,x)$}\\
$\mathcal{C} \gets \mathcal{C} \cup \{i\}$\\
Ret $M_i$\\
}
}
\caption{False-positive security for an $(n,k,m)$-filter~$B$ in the multiple-server setting.  (Three variations, depending on access to/knowledge of hash functions.) \textcolor{cyan}{Not clear which of these notions really makes sense.}}
\label{fig:fp-filter}
\end{figure}