\section{Hash-based Filters}
\heading{Preliminaries.}
When~$U$ is a set and $n>0$ is an integer, we let $[U]^n$ denote the set of all size-$n$ subsets of~$U$.
We write $x \getsr U$ to denote sampling an element from~$U$ and assigning this to~$x$, and we extend this notation to randomized algorithms.

\heading{Syntax.}
Fix a nonempty sets $U,\Sigma$ and integers $k,m,n>0$.  Fix a symbol $\bot \not\in U$.  An $(n,k,m)$-filter (over universe~$U$) is a tuple  $B=(\Hash,\Rep,\Qry)$.
%
The randomized \emph{hash-sampling} algorithm~$\Hash$ samples a
size~$k$  family of functions~$\mathcal{H}=\{h_1,h_2,\ldots,h_k\}$
where each $h_i \in  \mathrm{Func}(U,[m])$.  We write $\mathcal{H}
\getsr \Hash$ for this operation.
%
The randomized representation algorithm $\Rep\colon [U]^n \rightarrow
\Sigma^m \times \bits^*$ takes a set~$S$ of~$n$ elements as input, and outputs
representation~$M$ of length~$m$ along with (possibly empty) side-information~$\tau$.
%
The deterministic query algorithm $\Qry\colon \Sigma^m \times \bits^* \times U
\rightarrow \bits$ takes a representation $M$, side-information~$\tau$, and an element $x \in
U$, and returns a bit.
%
We assume that both $\Rep$ and $\Qry$ have blackbox access to the
functions $h_1,h_2,\ldots,h_k \in \mathcal{H}$.  Typically this access will be implicit, but when we need to make it explicit we will write~$\mathcal{H}$ (or the individual hash functions) as superscripts.
%which we denote by writing~$\mathcal{H}$ as a superscript.
%Thus, we write $M \gets \Rep^{\mathcal{H}}(S)$ and $b \gets \Qry^{\mathcal{H}}(M,x)$ for the execution of the representation and query algorithms, respectively.
%
%We write $M \gets \Rep(S)$ and $b \gets \Qry(M,x)$ for the execution of the representation and query algorithms, respectively.
For correctness, we demand that for all~$S$ of size~$n$ and all $x
\in S$, it holds that $\Prob{\mathcal{H}\getsr\Hash;\,(M,\tau)\getsr\Rep(S)\,:\,\Qry(M,\tau,x)=1}=1$, where the
probability is over the coins of $\Hash$ and~$\Rep$.


%\heading{Discussion.}
This syntax captures classical Bloom filters by setting~$\Sigma=\bits$,  and defining $\Rep,\Qry$ in the obvious way, with $\tau=\emptystring$. We note that even though $\Rep$ may be randomized, it does not have to be; for the classical Bloom filter, it is deterministic.

By allowing $\Rep$ to output side-information, we allow for (say) $\Rep$ and $\Qry$ to share a secret key selected during representation generation.  \tsnote{Ultimately it might be cleaner to fold the hash functions into the side-information, too.  But in that case, we will likely want an explicit separation between private side-information (e.g., the key for a secret permutation of the bits of~$M$) and public side-information (e.g., the hash functions used to create~$M$).  Note that we do see constructions that have \emph{no} ``stand-alone'' hash functions yet use a secret key (e.g., the PRF-based double-hashing construction), and also schemes that employ \emph{both} stand-alone hash functions and a secret key (e.g. the record BF from Durham et al.)}  In our security notions, any side-information will be kept secret from the adversary.

Setting $\Sigma=\bits^{\leq L}$ allows one to store a bitstring of length at most~$L$ at each location.  This allows our syntax to capture the cuckoo-hashing construction from NY, as well as the ``garbled Bloom filter'' from Dong, Chen and Wen~\cite{xxx}, among other things. We note that even though this would allow for the storage of counters (say) at each filter location, our restriction that~$\Qry$ returns a bit does not capture functionality typically demanded of Bloom filters that employ counters, e.g., returning a counter value. (One could, however, have $\Qry$ compute an arbitrary, fixed predicate.  For example, ``has~$x$ been seen at least 5 times?''.)
Our syntax also does not capture filters that are mutable, that is, whose representation may change over time.
On the other hand, we can state a simple correctness condition for these kinds of filters; this will not be true when we further generalize to capture, properly, counters and mutability.

\heading{FP-security of hash-based filters.} \tsnote{NY give it in
the private hash setting (sort of); but, intuitively, it should be
hard to find false-positives even if you know that MD5 or SHA-x are
the hash functions.  Not totally sure how to capture this intuition
nicely.} \jnote{Not sure I agree. First of all, if $\epsilon$ is not
negligible then a random element is a false positive with noticeable
probability. Beyond that, I think that intuitively it makes sense
that if you want false positives to be hard to find then you need to
make the hash functions secret.} \tsnote{I don't think it makes sense
to talk about asymptotics or negligibility, for exactly the reason you
state. I think the key point here is: what is ``hard''?   The designer decides what FP rate is
acceptable for a given application, a given set of efficiency
constraints, the side-effects of a FP, etc.  For a fixed FP target,
she optimizes the filter size and/or the number of hash functions for
her setting. Whether the target FP rate is 0.01 or $2^{-80}$, we should be able to say (in the ROM, at least)
that it will take this-many hash computations, and this many on-line
set-membership queries, to find the first FP.  In the standard model,
with public hash functions, it is clearly more difficult to make
formal claims.  Even so, in practice I expect it would be quite expensive to
find a string~$x$ such that $(h_1(x),h_2(x),\ldots,h_k(x))$
falls in a given set of tuples when $h_i(x)=\mathrm{truncate}(\mathrm{SHA256}(\langle i \rangle
\concat x), m)$, say. (Even more so if my setting admits relatively
expensive hash computations, e.g. SCRYPT.)  BTW, your suggestion to
have a FP notion with secret~$\mathcal{S}$ is interesting here. }


The traditional notion of soundness
for a Bloom filter captures the difficulty of finding false
positives when the attacker is non-adaptive. Following NY, we
consider soundness against adaptive adversaries. But we further
generalize to allow for settings in which the attacker may have some
a priori knowledge about the contents of~$S$. (The Niedermaier et
al.~\cite{xxx} attacks, for example, exploit knowledge about the
distribution of German last names.)   In particular, our notions
take as input an explicit distribution $\distr{U}{n}$ over~$[U]^n$.

\jknote{We also want to capture the fact that finding the first
false positive should not make it any easier to find subsequent
false positives. This is not really captured by the Naor paper,
either (at least not directly, though it may end up being implied by
their definition).} \tsnote{See my comment in the intro.}

In Figure~\ref{fig:fp-filter} we give three distinct notions,
characterized by what access the adversary has to the underlying
hash functions used by the filter.  In the top notion, the hash
functions are secret.  This is the setting addressed by NY, and it
captures applications in which the hash functions are (say) secretly
keyed PRFs, and in which no explicit, external interface to these is
surfaced.
%
The bottom notion considers the case that the full code of the hash functions is known to the attacker.  This is the case, for example, when attacking the Bloom filters used in the Squid proxy~\cite{xxx}.
%
The middle notion is a compromise: it makes the hash functions
public, but assumes that the adversary only accesses them in a
black-box manner.  That is, the adversary does not exploit
structural features of the hash functions in its attack.  This
notion makes it easy to track the query complexity of an attack, and
also allows us to capture constructions in the random-oracle model.

For each experiment, we define an associated advantage
notion.  Namely, given an $(n,k,m)$-filter~$B=(\Hash,\Rep,\Qry)$,
distribution~$\distr{U}{n}$ and adversary~$A$, we define:
\begin{align*}
\AdvFPSecHash{B}{\distr{U}{n},A} &= \Prob{\ExpFPSecHash{B}{\distr{U}{n},A}} \\
\AdvFPPubHashBB{B}{\distr{U}{n},A} &= \Prob{\ExpFPPubHashBB{B}{\distr{U}{n},A}} \\
\AdvFPSecHash{B}{\distr{U}{n},A} &= \Prob{\ExpFPPubHash{B}{\distr{U}{n},A}}
\end{align*}
The probabilities are over the coins of the indicated experiment,
and the coins of the adversary.   In all experiments, we track the
time-complexity~$t$ of~$A$, as well as the number of set-membership
($\QryOracle$ oracle) queries~$q_{\mathrm{sm}}$ that it makes.   In
the second, we also track the number of hash-queries
$q_{\mathrm{h}}$ that the adversary makes.

We note that the distribution~$\distr{U}{n}$ must be independent of the hash functions $h_1,h_2,\ldots,h_k$ that are used to create~$M$.  Otherwise, when (say) $\Sigma=\bits$, the distribution may only assign positive probability to sets~$S$ that cause an abnormally large number of bits in~$M$ to be set to 1.  Our security notions enforce this independence.

\jnote{How do we want to define a ``secure'' Bloom filter (even
informally)? Do we want to say that the probability of finding a
false positive is negligible? Or that if we set the FP rate to
$\epsilon$ then the best an attacker can do with $q$ hash queries is
$1-(1-\epsilon)^q$ plus negligible?} 
\tsnote{Formally, I don't think we can (and still be rooted in
  reality.)  Even informally it's hard, since the fact is that the
  designer decides what is ``secure'' for her setting.  I think we
  just say something like ``A bloom filter is
  $(t,q_h,q_m,\epsilon)$-secure if no attacker running in time at
  most~$t$, asking at most~$q_h$ hash queries and $q_m$ set-membership
  queries, has probability more than~$\epsilon$ of finding a FP.''  (If
you like, we can throw a paramter~$n$ in there, for the number of FPs
it must find.)  Perhaps informally we say that a bloom filter is
secure if, for ``reasonable'' $t,q_h,q_m$, the value of~$\epsilon$ is
not ``significantly larger'' than the designer's target.  I guess
that's not far off from one of your suggestions.}

\jnote{One thing that is nice about the
NY notion is that you get a ``clean'' definition of security: no
matter how many FPs the attacker has found so far, the probability
that it can output a fresh FP is still $\epsilon$.}

\jnote{What parameters are needed to get negligible $\epsilon$? Are
they reasonable in practice?} \tsnote{Again, I don't think that
negligible is reasonable in practice :P}

\begin{figure}
\centering
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPSecHash{B}{\distr{U}{n},A}$}\\
$S \getsr \distr{U}{n}$\\
$h_1,\ldots,h_k \getsr \Hash$\\
$\HashOracle = (h_1, \ldots, h_k)$\\
$(M,\tau) \getsr \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,\tau,x)=1$ then\\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,\tau,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPPubHashBB{B}{\distr{U}{n}, A}$}\\
$S \getsr \distr{U}{n}$\\
$h_1,\ldots,h_k \getsr \Hash$\\
$\HashOracle = (h_1, \ldots, h_k)$\\
$(M,\tau) \getsr \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle,\HashOracle}(S)$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,\tau,x)=1$ then\\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,\tau,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPPubHash{B}{\distr{U}{n}, A}$}\\
$S \getsr \distr{U}{n}$\\
$h_1,\ldots,h_k \getsr \Hash$\\
$\HashOracle = (h_1, \ldots, h_k)$\\
$(M,\tau) \gets \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}(S,\{h_1,h_2,\ldots,h_k\})$\\
if $x \not\in S \wedge \Qry^{\HashOracle}(M,\tau,x)=1$ then\\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,\tau,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
} } \caption{False-positive security (soundness) for an
$(n,k,m)$-filter~$B$ with private hash functions (top), black-box
queriable hash functions (middle), and public hash functions
(bottom). \jnote{Could also consider not giving $S$ to the
adversary.} } \label{fig:fp-filter}
\end{figure}


%%%%
% \if{0}
% \begin{figure}
% \centering
% \fpage{.6}{
% \hpagess{.6}{.35}
% {
% \experimentv{$\ExpFPSecHash{S,B}{A}$}\\
% $ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
% $M \gets \Rep^{\HashOracle}(S)$\\
% $x \getsr A^{\QryOracle}(S)$\\
% if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
% \nudge Ret 1\\
% Ret 0
% }
% %
% {
% \oracle{$\QryOracle(x)$}\\
% Ret $\Qry^{\HashOracle}(M,x)$\\

% \medskip
% \oracle{$\HashOracle(i,x)$}\\
% Ret $h_i(x)$\\
% }
% }
% %%%%%%%
% \fpage{.6}{
% \hpagess{.6}{.35}
% {
% \experimentv{$\ExpFPPubHashBB{S,B}{A}$}\\
% $ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
% $M \gets \Rep^{\HashOracle}(S)$\\
% $x \getsr A^{\QryOracle,\HashOracle}(S)$\\
% if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
% \nudge Ret 1\\
% Ret 0
% }
% %
% {
% \oracle{$\QryOracle(x)$}\\
% Ret $\Qry^{\HashOracle}(M,x)$\\

% \medskip
% \oracle{$\HashOracle(i,x)$}\\
% Ret $h_i(x)$\\
% }
% }
% %%%%%%%
% \fpage{.6}{
% \hpagess{.6}{.35}
% {
% \experimentv{$\ExpFPPubHash{S,B}{A}$}\\
% $ \{h_1,h_2,\ldots,h_k\} \getsr \Hash$\\
% $M \gets \Rep^{\HashOracle}(S)$\\
% $x \getsr A^{\QryOracle}(S,\{h_1,h_2,\ldots,h_k\})$\\
% if $x \not\in S \wedge \Qry^{\HashOracle}(M,x)=1$ then\\
% \nudge Ret 1\\
% Ret 0
% }
% %
% {
% \oracle{$\QryOracle(x)$}\\
% Ret $\Qry^{\HashOracle}(M,x)$\\

% \medskip
% \oracle{$\HashOracle(i,x)$}\\
% Ret $h_i(x)$\\
% }
% }
% \caption{False-positive security (soundness) for an $(n,k,m)$-filter~$B$ with private hash functions (top), black-box queriable hash functions (middle), and public hash functions (bottom). }
% \label{fig:fp-filter}
% \end{figure}
%\fi
%%%%%



\heading{Privacy of hash-based filters.} We now define privacy notions for $(n,k,m)$-filters.  Informally, the adversary's goal is to guess one of the elements of the set~$S$.  Of course, if the distribution~$\distr{U}{n}$ has low min-entropy with respect to any particular element $x \in U$, then it will be relatively easy to guess~$x$.  To capture this min-entropy, let $p_{\mathrm{max}} = \max_{x \in U} \Prob{S \getsr \distr{U}{n}:\, x \in S}$ and define $\mu = -\log_2 p_{\mathrm{max}}$ to be the (element-wise) min-entropy of distribution $\distr{U}{n}$.

We note that~$S$ must be independent of the hash functions~$h_1,h_2,\ldots,h_k$ used to create the representation of~$S$.  \tsnote{I thought this would be needed, but now I'm not sure it is. }

\begin{figure}
\centering
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpPrivSecHash{B}{\distr{U}{n}, A}$}\\
$S \getsr \distr{U}{n}$\\
$h_1,\ldots,h_k \getsr \Hash$\\
$\HashOracle = (h_1, \ldots, h_k)$\\
$(M,\tau) \getsr \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}()$\\
if $x\in S$ then Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,\tau,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpPrivPubHashBB{B}{\distr{U}{n}, A}$}\\
$ S \getsr \distr{U}{n}$\\
$h_1,\ldots,h_k \getsr \Hash$\\
$\HashOracle = (h_1, \ldots, h_k)$\\
$(M,\tau) \getsr \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle,\HashOracle}()$\\
if $x\in S$ then Ret 1\\
Ret 0\\
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,\tau,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpPrivPubHash{B}{\distr{U}{n}, A}$}\\
$ S \getsr \distr{U}{n}$\\
$h_1,\ldots,h_k \getsr \Hash$\\
$\HashOracle = (h_1, \ldots, h_k)$\\
$(M,\tau) \getsr \Rep^{\HashOracle}(S)$\\
$x \getsr A^{\QryOracle}(\{h_1,h_2,\ldots,h_k\})$\\
if $x\in S$ then Ret 1\\
Ret 0\\
}
%
{
\oracle{$\QryOracle(x)$}\\
Ret $\Qry^{\HashOracle}(M,\tau,x)$\\

\medskip
\oracle{$\HashOracle(i,x)$}\\
Ret $h_i(x)$\\
}
}
\caption{Set-privacy for an $(n,k,m)$-filter~$B$ for private (top), black-box queriable (middle),  and public (bottom) hash functions. \textcolor{cyan}{Revisit when the FP notion settles out.}}
\label{fig:fp-filter}
\end{figure}

\heading{Security in multiple-server settings. }  \jnote{What is the
goal here? If they don't share hash functions, I'm not sure what is
gained by considering this definition.} \tsnote{Perhaps not the same
hash functions, but correlated ones.  For example, server~$j$ uses
hash functions $\tilde{h}_i(x) = h_i(\langle \mathrm{id}_j \rangle \concat x)$ for
some $h_i$ shared among servers.  The $\mathrm{id}_j$ may or may not
be public, e.g. in a P2P network your ID might be a nonce learned only
when you join.  Also, the sets $\mathcal{S_j}$ stored at each server
might be correlated.} In this section, we consider
security notions for settings in which there may be multiple
servers, each holding a filter representation of a set.  To allow
for each server to embed server-specific information into its
representation, we abstract the servers as $B_1,B_2,\ldots,B_\ell$
where each $B_i=(\Hash_i,\Rep_i,\Qry_i)$ is an $(n,k,m)$-filter.
\tsnote{Still some kinks to be ironed out though.  The current
notions sample fresh hash functions for each server.  But in (say)
the Squid setting, the same hash functions are used across all Squid
instances... maybe it suffices, for that setting, to say that the
$\Hash_i$ are all the same, and each simply returns a fixed set
of~$k$ hash functions (i.e., deterministic).} To model insider
attacks, we give the adversary the ability to corrupt (adaptively)
instances of the filter.  Such attacks capture P2P settings, in
which the adversary may join the network as a peer.

\begin{figure}
\centering
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPSecHash{B_1,B_2,\ldots,B_\ell}{\distr{U}{n}, A}$}\\
$\mathcal{C} \gets \emptyset$\\
for $i=1$ to $\ell$\\
\nudge $S_i \getsr \distr{U}{n}$\\
\nudge $ \mathcal{H}_i \gets \{h^i_1,h^i_2,\ldots,h^i_k\} \getsr \Hash_i$\\
\nudge $M_i \getsr \Rep_i^{\HashOracle(i,\cdot,\cdot)}(S_i)$\\
$(i,x) \getsr A^{\QryOracle,\CorruptOracle}(\{S_i\}_{i=1}^{\ell})$\\
if $i \not\in \mathcal{C} \wedge \Qry_i^{\HashOracle(i,\cdot,\cdot)}(M_i,x)=1$ then \\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(i,x)$}\\
Ret $\Qry_i^{\HashOracle}(M_i,x)$\\

\medskip
\oracle{$\HashOracle(i,j,x)$}\\
Ret $h^i_j(x)$\\

\medskip
\oracle{$\CorruptOracle(i,x)$}\\
$\mathcal{C} \gets \mathcal{C} \cup \{i\}$\\
Ret $M_i,\mathcal{H}_i$\\
}
}
%%%%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPPubHashBB{B_1,B_2,\ldots, B_\ell}{\distr{U}{n}, A}$}\\
$\mathcal{C} \gets \emptyset$\\
for $i=1$ to $\ell$\\
\nudge $S_i \getsr \distr{U}{n}$\\
\nudge $ \{h^i_1,h^i_2,\ldots,h^i_k\} \getsr \Hash_i$\\
\nudge $M_i \getsr \Rep_i^{\HashOracle(i,\cdot,\cdot)}(S_i)$\\
$(i,x) \getsr A^{\QryOracle,\HashOracle,\CorruptOracle}(\{S_i\}_{i=1}^{\ell})$\\
if $i \not\in \mathcal{C} \wedge \Qry_i^{\HashOracle(i,\cdot,\cdot)}(M_i,x)=1$ then \\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(i,x)$}\\
Ret $\Qry_i^{\HashOracle}(M_i,x)$\\

\medskip
\oracle{$\HashOracle(i,j,x)$}\\
Ret $h^i_j(x)$\\

\medskip
\oracle{$\CorruptOracle(i,x)$}\\
$\mathcal{C} \gets \mathcal{C} \cup \{i\}$\\
Ret $M_i$\\
}
}
%%%%%%%
\fpage{.6}{
\hpagess{.6}{.35}
{
\experimentv{$\ExpFPPubHash{B_1,B_2,\ldots,B_\ell}{\distr{U}{n}, A}$}\\
$\mathcal{C} \gets \emptyset$\\
for $i=1$ to $\ell$\\
\nudge $S_i \getsr \distr{U}{n}$\\
\nudge $ \mathcal{H}_i \gets \{h^i_1,h^i_2,\ldots,h^i_k\} \getsr \Hash_i$\\
\nudge $M_i \getsr \Rep_i^{\HashOracle(i,\cdot,\cdot)}(S_i)$\\
$(i,x) \getsr A^{\QryOracle,\CorruptOracle}(\{S_i\}_{i=1}^{\ell},\{\mathcal{H}_i\}_{i=1}^{\ell})$\\
if $i \not\in \mathcal{C} \wedge \Qry_i^{\HashOracle(i,\cdot,\cdot)}(M_i,x)=1$ then \\
\nudge Ret 1\\
Ret 0
}
%
{
\oracle{$\QryOracle(i,x)$}\\
Ret $\Qry_i^{\HashOracle}(M_i,x)$\\

\medskip
\oracle{$\HashOracle(i,j,x)$}\\
Ret $h^i_j(x)$\\

\medskip
\oracle{$\CorruptOracle(i,x)$}\\
$\mathcal{C} \gets \mathcal{C} \cup \{i\}$\\
Ret $M_i$\\
}
}
\caption{False-positive security for an $(n,k,m)$-filter~$B$ in the multiple-server setting.  (Three variations, depending on access to/knowledge of hash functions.) \textcolor{cyan}{Not clear which of these notions really makes sense.}}
\label{fig:fp-filter}
\end{figure}
