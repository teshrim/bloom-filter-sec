\begin{figure}[tp]
\centering
\hfpages{.45}
{
\algorithmv{$\Rep(S)$}\\
$M \gets 0^m$; $K_1,K_2 \getsr \calK$\\
for $x \in S$\\
\nudge for $j \in \{1,2,\ldots,k\}$\\
\nudge\nudge $h_j \gets F_{K_1}(x) + j\cdot F_{K_2}(x) \bmod m$\\
\nudge\nudge $M[h_j] \gets 1$\\
$\pubaux \gets M$, $\privaux \gets \langle K_1, K_2 \rangle$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry(\pubaux,\privaux,q_x)$}\\
$M\gets\pubaux$, $K_1,K_2 \gets \privaux$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets F_{K_1}(x) + j\cdot F_{K_2}(x) \bmod m$\\
\nudge if $M[h_j] \neq 1$ then Return 0\\
Return 1
}
{
\algorithmv{$\Rep(S)$}\\
$M \gets 0^m$; $K \getsr \calK$\\
for $x \in S$\\
\nudge for $j \in \{1,2,\ldots,k\}$\\
\nudge\nudge $h_j \gets F_{K}(j,x) $\\
\nudge\nudge $M[h_j] \gets 1$\\
$\pubaux \gets M$, $\privaux \gets \langle K_1, K_2 \rangle$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry(\pubaux,\privaux,q_x)$}\\
$M\gets\pubaux$, $K \gets \privaux$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets F_{K}(j,x) $\\
\nudge if $M[h_j] \neq 1$ then Return 0\\
Return 1
}
\caption{{\bf Left:} $\Rep$ and $\Qry$ algorithms for the linear-PRF
  data structure $\Pi_{\mathrm{lin}}$, with function family $F \colon
  \calK \times \univ \to [m]$. {\bf Right:} $\Rep$ and $\Qry$
  algorithms for the domain-separated PRF data structure
  $\Pi_{\mathrm{ds}}$, with function family $F \colon \calK \times
  [k]\times\univ \to [m]$.  For both, the query set is $\calQ=\{q_x\colon
  \univ \to \bits\}$ where $q_x(S)=1 \Leftrightarrow x \in S$.  }
\label{fig:lin-and-ds}
\end{figure}

\begin{figure}[pt]
\centering
\fpage{0.95}{
\hpagessl{.4}{.55}
{
\algorithmv{$\Rep^H(S)$}\\
$M \gets 0^m$\\
for $x \in S$\\
\nudge for $j \in \{1,2,\ldots,k\}$\\
\nudge\nudge $h_j \gets H(j,x)$\\
\nudge\nudge $M[h_j] \gets 1$\\
$\pubaux \gets M$, $\privaux \gets \emptystring$\\
Return $(\pubaux,\privaux)$\\

\medskip
\algorithmv{$\Qry^H(\pubaux,\privaux,q_x)$}\\
$M\gets\pubaux$\\
for $j \in \{1,2,\ldots,k\}$\\
\nudge $h_j \gets H(j,x)$\\
\nudge if $M[h_j] \neq 1$ then Return 0\\
Return 1
}
{
\algorithmv{$\Rep^H(S)$}\\
$M \gets \mathrm{null}^m$; $\lambda \gets \calK$\\
for $x \in S$\\
\nudge $\finalshare \gets 0^\lambda$; $\emptyslot \gets -1$\\
\nudge for $j \in \{1,2,\ldots, k\}$\\
\nudge \nudge $h_j \gets H(j,x)$\\
\nudge \nudge if $M[h_j] \neq \mathrm{null}$ then\\
\nudge \nudge \nudge $\finalshare \gets \finalshare \xor M[h_j]$\\
\nudge \nudge else if $\emptyslot = -1$ then\\
\nudge \nudge \nudge $\emptyslot \gets h_j$\\
\nudge \nudge else\\
\nudge \nudge \nudge $M[h_j] \gets \bits^\lambda$\\
\nudge \nudge \nudge $\finalshare \gets \finalshare \xor M[h_j]$\\
\nudge $M[\emptyslot] \gets \finalshare \xor x$\\
for $i \in \{1,2,\ldots, m\}$\\
\nudge if $M[i] = \undefined$ then\\
\nudge \nudge  $M[i] \gets \bits^\lambda$\\
$\pubaux \gets M$; $\privaux \gets \lambda$\\

\medskip
\algorithmv{$\Qry(\pubaux,\privaux,q_x)$}\\
$M \gets \pubaux$, $\lambda \gets \privaux$, $x \gets 0^\lambda$\\
for $j \in \{1,2,\dots,k\}$\\
\nudge $h_j \gets H(j,x)$\\
\nudge $x \gets x \xor M[h_j]$\\
if $x = q_x$ then Return 1\\
Return 0
}
}
\caption{{\bf Left:} $\Rep$ and $\Qry$ algorithms for classic Bloom
  filter $\Pi_{\mathrm{Bloom}}$ in the ROM for a hash function $H\colon \mathbb{N} \times
  \univ \to [m]$. {\bf Right:} $\Rep$ and $\Qry$ algorithms for garbled Bloom
  filter $\Pi_{\mathrm{garbled}}$ in the ROM for a hash function $H\colon \mathbb{N} \times \calK
 \times \univ \to [m]$. For both, the query set is $\calQ=\{q_x\colon
  \univ \to \bits\}$ where $q_x(S)=1 \Leftrightarrow x \in S$.  }
\label{fig:bf-and-garbled-bf}
\end{figure}

\begin{figure}
\centering
\hfpages{.45}
{\algorithmv{$\Rep(S)$}\\
$\pubaux \gets \emptystring$\\
$K_1,K_2, \getsr \calK$\\
for each $x \in S$\\
\nudge $M_x \gets 0^m$\\
\nudge $B_x \gets \mathsf{bigram}(x)$\\
\nudge for each $b \in B_x$\\
\nudge\nudge for $j \in [k]$\\
\nudge\nudge\nudge $i \gets F_{K_1}(b)+j\cdot F_{K_2}(b) \bmod m$\\
\nudge\nudge\nudge $M_x[i] \gets 1$\\
\nudge $\pubaux \gets \langle\pubaux, M_x \rangle$\\
$\privaux \gets \langle K_1,K_2 \rangle$\\
Return $(\pubaux,\privaux)$
}
{
\algorithmv{$\Qry(\pubaux,\privaux,q_x)$}\\
$B \gets \mathsf{bigram}(x)$\\
$\overline{M} \gets 0^m$\\
for each $b \in B$\\
\nudge for $j \in [k]$\\
\nudge\nudge $i \gets F_{K_1}(b)+j\cdot F_{K_2}(b) \bmod m$\\
\nudge\nudge $\overline{M}[i] \gets 1$\\
if $M \in \pubaux$ then Return 1 \\
Return 0
}
\caption{The scheme from Neidermayer et al.\cite{xxx}}
\label{fig: neidermayer}
\end{figure}