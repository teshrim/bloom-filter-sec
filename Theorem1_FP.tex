%\heading{Linear-PRF construction. }
%Here we consider a set-multiplicity data structure that was attacked by Neidermayer et al. in~\cite{xxx}.  Let $\Pi_{\mathrm{lin}}= (\Sigma,\Gamma,\calS,\calQ,\Rep, \Qry)$ be defined as follows. Fix an $n \geq 0$, let $\mathcal{S}=[\univ]^n$, and let $\Sigma=\Gamma=\bits$. The queries are defined so that $q_x(S)=1$ if $x \in S$, and 0 otherwise.  Fix non-empty sets ~$\calK$, $\univ$ and integers $k,m,n>0$.  Let $F\colon\mathcal{K} \times \univ \to [m]$ be a function family. Define $\Hash$ as an algorithm that samples two keys $K_0,K_1 \getsr \mathcal{K}$ and defines $h_j(x) = F_{K_0}(x) + j\cdot F_{K_1}(x) \bmod m$ for $j \in [1,k]$.  $\Rep$ uses $\Hash$ to set $\privaux=\pubaux = (h_1, \ldots, h_k)$, and computes an $m$ bit array, $M$ in the standard way and returns $(M,\pubaux,\privaux)$.  The $\Qry$ algorithm gets $(M,\privaux, q_x)$ as input, and returns the AND of values at $M[h_1(x)],\ldots,M[h_k(x)]$. It must be noted that $\Pi_{\mathrm{lin}}$ admits errors in form of false-positives(FP) only. So, error rate of $\Pi_{\mathrm{lin}}$ is same as the (non-adaptive) FP rate. The following result shows, informally, that if~$F$ is a good PRF and the error rate is sufficiently small, then $\Pi_\mathrm{lin}$ is correct against adaptive error-finding adversaries. Henceforth, we refer errors and error-rate in $\Pi_{\mathrm{lin}}$ as FP's and FP rate, respectively.
%
%\begin{theorem}\label{thm1}
%Fix $k,m,n,r>0$, and let $\Pi_{\mathrm{lin}}= (\Sigma,\Gamma,\calS,\calQ,\Rep, \Qry)$ be the set-multiplicity data structure just described. For any adversary~$A$ that makes a total of~$q$ queries to its oracle and has time-complexity~$O(t)$, there exist adversaries~$B_1,B_2$ (explicitly constructed in the proof of this theorem) such that
%\[
%\AdvCorrect{\Pi_{\mathrm{lin}},\distr{\calS}{},r}{A} \leq  \AdvPRF{F}{B_1} + \AdvPRF{F}{B_2}  +{\dbinom{q}{r}} \left( (1-e^{-kn/m})^k + O(1/n) \right)^r\,.
%\]
%Here, $B_1$ and $B_2$, each ask~$q$ oracle queries and have time complexity~$O(t+qm)$.
%\end{theorem}
%Before giving the proof, we note that Kirsch and Mitzenmacher~\cite{xxx} show
%that the ($r=1$, non-adaptive) FP-probability for~$\Pi_\mathrm{lin}$ is
%always within $O(1/n)$ of $(1-e^{-kn/m})^k$, although the asymptotic
%rate of convergence is faster than~$1/n$.  The factor of $\dbinom{q}{r}$ arises as a result
%of removing adaptivity.  Finally, $\dbinom{q}{r} \leq q^r$ (with
%reasonable tightness when~$r$ is small) in which case the final term in the bound behaves as 
%$(q (1-e^{-kn/m})^k + O(q/n) )^r$; loosely, the bound one expects for
%trying to find a single FP in each of~$r$ independent``rounds'', each round
%consisting of~$q$ attempts.

\begin{proof}[\Cref{thm1}]
The proof of the theorem will use a game playing argument as shown in \Cref{fig:Game}. $\game{0}(A)$ exactly simulates $\ExpCorrect{\Pi_\mathrm{lin},\distr{\calS}{},r}{A}$ with hash functions $h_j(x) =  F_{K_0}(x) + j\cdot F_{K_1}(x) \bmod m$. So,

\begin{equation}
\AdvCorrect{\Pi_{\mathrm{lin}},\distr{\calS}{},r}{A} = \Prob{\game{0}(A)=1}\label{eq:0}
\end{equation}

 In $\game{1}(A)$, $F_{K_1}$ is replaced by a random function, whereas in $\game{2}(A)$, both $F_{K_0}$ and $F_{K_1}$ are replaced by random functions.

%\caption{Adversary $B_1, B_2$ simulating $\game{1}(A)$ and $\game{2}(A)$ respectively}\label{fig:BGame1}
\begin{figure}
\fpage{0.9}{
\hpagessl{0.5}{0.5}
{
$\adversaryv{B_1^{\calO}}$\\
$S \getsr \distr{\calS}{}$\\
$\err \gets 0$\\
$(M,\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
Run~$A(S, \pubaux)$\\
When $A$ asks $\TestOracle(q)$:\\
\nudge $a \gets \Qry^{\HashOracle}(M,\privaux,q)$\\
\nudge if $a \neq q(S)$ then \\
\nudge \nudge $\err \gets \err +1$\\
\nudge Return~$(a,\err )$\\
When $A$ halts: \\
\nudge if $\err  < r$ then Return 0\\
\nudge Return 1\\\\
%
\oracle{$\HashOracle(x)$}\\
$ \mathrm{Ret} \nudge F_{K_1}(x) + i\cdot \calO(x)$, for $i\in[1,k]$\\
}
{
$\adversaryv{B_2^{\calO}}$\\
$S \getsr \distr{\calS}{}$\\
$\err \gets 0$\\
$(M,\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
Run~$A(S, \pubaux)$\\
When $A$ asks $\TestOracle(q)$:\\
\nudge $a \gets \Qry^{\HashOracle}(M,\privaux,q)$\\
\nudge if $a \neq q(S)$ then \\
\nudge \nudge $\err \gets\err +1$\\
\nudge Return~$(a,\err )$\\
When $A$ halts: \\
\nudge if $\err  < r$ then Return 0\\
\nudge Return 1\\\\
\oracle{$\HashOracle(x)$}\\
$a \getsr [m]$\\
if $T[x] \neq \undefined$\\
\nudge $a \gets T[x]$\\
$T[x] \gets a$\\
Ret  $\calO(x) + i\cdot a$, for $i\in[1,k]$
}
}
\caption{\Cref{thm1}:Adversary $B_1, B_2$ simulating $\game{1}(A)$ and $\game{2}(A)$ respectively}\label{fig:BGame1}
\end{figure}

The PRF security notion is shown in \Cref{fig:prf}. Let
prf-adversaries $B_1, B_2$ be as shown in \Cref{fig:BGame1}.
Adversary~$B_1$ is constructed so that, if its challenge bit~$b=1$,
then it exactly simulates $\game{0}$ for~$A$; if $b=0$, it
simulates~$\game{1}$.  Similarly, adversary~$B_2$ simulates~$\game{1}$
if its challenge bit~$b=1$, and $\game{2}$ otherwise.  We can conclude
that 
\begin{align*}
\Prob{\ExpPRF{F}{B_1} = 1\,|\,b=1} &= \Prob{\game{0}(A)=1} \\%\label{eq:m1}\\
\Prob{\ExpPRF{F}{B_1} = 1\,|\,b=0} &= 1-\Prob{\game{1}(A)=1} \\%\label{eq:m3}\\
\Prob{\ExpPRF{F}{B_2} = 1\,|\,b=1} &= \Prob{\game{1}(A)=1} \\%\label{eq:m2}\\
\Prob{\ExpPRF{F}{B_2} = 1\,|\,b=0} &= 1-\Prob{\game{2}(A)=1} \\%\label{eq:m4}
\end{align*}
%
\noindent
By a standard conditioning of the PRF advantage, we have 
\begin{equation*}
\Prob{\game{0}(A)=1} = \AdvPRF{F}{B_1} +\AdvPRF{F}{B_2} + \Prob{\game{2}(A)=1}%\label{eq:13}
\end{equation*}


In $\game{3}(A)$, we replace the random functions used in
$\HashOracle$ (in $\game{2}(A)$) with lazy sampling of elements from
$[m]$.  This change does not alter the behavior of the oracle, as the
random functions are (by the no-pointless-queries assumption on~$A$) always called on a new
value of~$x$.
%
Also, the $\Test$ oracle now sets $\bad$ to $\true$ if the
queries indexed by the set $\mathcal{I}$ fail to be false-positives,
or if any of the remaining queries are false-positives. It can be
observed that the $\bad$ flag has no impact on the output of the
$\Test$, nor does it affect  the value returned
by~$\game{3}$. Thus we have $\Prob{\game{2}(A)=1} =
\Prob{\game{3}(A)=1}$ and
\[
\Prob{\game{3}(A)=1 \wedge \game{3}(A): \neg\bad} = \Prob{\game{3}(A)=1} \Prob{\game{3}(A) : \neg\bad}%\label{eq:1} \\
\]

We note that $\game{3}$ and $\game{4}$ are
``identical-untill-$\bad$''~\cite{BeRo-gameplaying}.  In particular,
in $\game{4}$, $A$ returns 0 when $\game{3}$ would have returned 1 (i.e.,
the adversary outputs~$r$ false-positives, but $\bad=\true$).  
Moreover,  $\game{4}(A)$ returning 1 implies that $\bad$ is never set to $\true$. Therefore,
$\Prob{\game{4}(A)=1} = \Prob{\game{3}(A)=1 \wedge \neg\bad} =
\Prob{\game{3}(A)=1} \Prob{\game{3}(A) : \neg\bad}$, by our previous observation.

Before continuing the proof, a bit of intuition for the introduction
of the $\bad$-flag in games~$\game{3},\game{4}$.   Intuitively, if the index
set~$\mathcal{I}$ exactly predicts which of the $\Test$ queries will be
false-positives (and, conversely, which will not be), then a
non-adaptive FP-finding adversary can ``guess'' which of~$A$'s queries require it
to return 1 when simulating the $\Test$, and which require it to
return 0.  In this way, no queries ever actually need to be made.
Moving to a non-adaptive setting will allow us to connect to classical
results on the FP-rate of Bloom filters; more in a moment. 

Now, consider $\Prob{\game{3}(A) : \neg\bad}$.  The indicated event
happens iff the $r$-set~$\calI$ contains exactly the indices of
$\Test$-queries that are false-positives.  Since the value
of~$\bad$ does not alter the responses of~$\Test$, $\err$'s update
and the set~$\calI$ are independent.
Thus $\bad$ remains $\false$ after~$A$ halts with probability
$1/\dbinom{q}{r}$, and we have 
\begin{equation*}
\Prob{\game{4}(A)=1} = \frac{1}{\dbinom{q}{r}}\Prob{\game{3}(A)=1}
\end{equation*}

Recall that adversary~$A$ wins $\ExpCorrect{\Pi_{\mathrm{lin}},\distr{\calS}{},r}{}$ by finding~$r$ false positives. We can assume, without loss of generality,  that~$A$ halts immediately upon finding its $r$-th false positive. % We can also assume that every point in $\calZ$ has already been queried to $\Test$.  This latter assumption is not without loss, but can be  easily enforced (in the original security definitions) by counting as part of the number of queries~$q$, the points in $\mathcal{Z}$. 
%
%Under these assumptions,
So, if $\game{4}(A)=1$, then there is a non-adaptive adversary~$D$ that finds~$r$ false positives against $\tilde{\Pi}_{\mathrm{lin}}$, which is $\Pi_{\mathrm{lin}}$ but with $F_{K_1}$ and $F_{K_2}$ replaced by random functions $\rho_1$ and $\rho_2$, respectively.  We give this~$D$ in \Cref{fig:D}. Intuitively, adversary~$D$ guesses which~$r$ of~$A$'s queries will be false positives; it simulates the~$\Test$ oracle by returning 1 on the guessed queries, and 0 otherwise; and it halts after finding $r$ FP's.  Thus we have
$\Prob{\game{4}(A)=1} =\Prob{\ExpCorrect{\tilde{\Pi}_{\mathrm{lin}},\distr{\calS}{},r}{D} = 1}$.

Note that $\tilde{\Pi}_{\mathrm{lin}}$ is the scheme that is analyzed in the classical Bloom filter literature ---the hash functions are modeled as independent random functions, and the parameters $k,m,n$  are set to achieve a target maximum false-positive probability (or rate).  Kirsch and Mitzenmacher~\cite{KM} show that the upperbound on false-positive probability for a non-adaptive adversary and $r=1$ is $\left( (1-e^{-kn/m})^k + O(1/n) \right)$.  For $r>1$, we observe that~$A$'s queries $x_1,x_2,\ldots,x_q$ are distinct and not elements of the original set~$S$, since we assume no pointless queries. Let $\calF_i$ be the event that~$x_i(i \in \mathcal{I})$ is a false positive.  Since $\game{4}$ (equivalently $\tilde{\Pi}_{\mathrm{lin}}$) use independent random functions, the events $\calF_1,\calF_2,\ldots,\calF_r$ are independent. 
\[
\Prob{\ExpCorrect{\tilde{\Pi}_{\mathrm{lin}},\distr{\calS}{},r}{D} = 1}\leq \left( (1-e^{-kn/m})^k + O(1/n) \right)^r 
\]

To summarize, we have 
\[
\AdvCorrect{\Pi_{\mathrm{lin}},\distr{\calS}{},r}{A}  \leq  \AdvPRF{F}{B_1} +\AdvPRF{F}{B_2} +\dbinom{q}{r}\left( (1-e^{-kn/m})^k + O(1/n) \right)^r
\]
which is the bound claimed in the theorem statement. %\hfill \qed

%\caption{Game playing argument}\label{fig:Game}
\begin{figure}
\fpage{.9}{
\hpagessl{.45}{.5}
{
\underline{\game{0}(A)}\\
$S \getsr \distr{\calS}{}$\\
$\err \gets 0$\\
$(M,\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
$z \getsr A^{\TestOracle}(S,\pubaux)$\\
if $\err  < r$ then Return 0\\
Return 1\\
%
\oracle{$\TestOracle(q)$}\\
$a \gets \Qry^{\HashOracle}(M,\privaux,q)$\\
if $a \neq q(S)$ then \\
\nudge $\err \gets\err +1$\\
Return~$(a,\err )$\\
%
\oracle{$\HashOracle(x)$}\\
for $i = 1$ to $k$\\
\nudge $h_i(x) = F_{K_1}(x)+i \cdot F_{K_2}(x) \bmod m$\\
Ret $\left(h_1(x),\ldots,h_k(x)\right)$
}
{
\underline{\game{1}(A)}\\
$\rho \getsr \Func{\univ,[m]}$\\
$S \getsr \distr{\calS}{}$\\
$\err \gets 0$\\
$(M,\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
$z \getsr A^{\TestOracle}(S,\pubaux)$\\
if $\err  < r$ then Return 0\\
Return 1\\
%
\oracle{$\TestOracle(q)$}\\
$a \gets \Qry^{\HashOracle}(M,\privaux,q)$\\
if $a \neq q(S)$ then \\
\nudge $\err \gets\err +1$\\
Return~$(a,\err )$\\
%
\oracle{$\HashOracle(x)$}\\
for $i=1$ to $k$\\
\nudge $h_i(x) = F_{K_1}(x)+i \cdot \rho(x) \bmod m$\\
Ret $\left(h_1(x),\ldots,h_k(x)\right)$
}
}
\fpage{.9}{
\hpagessl{.45}{.5}
{
\underline{\game{2}(A)}\\
$\rho_1,\rho_2 \getsr \Func{\univ,[m]}$\\
$S \getsr \distr{\calS}{}$\\
$\err \gets 0$\\
$(M,\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
$z \getsr A^{\TestOracle}(S,\pubaux)$\\
if $\err  < r$ then Return 0\\
Return 1\\
%
\oracle{$\TestOracle(q)$}\\
$a \gets \Qry^{\HashOracle}(M,\privaux,q)$\\
if $a \neq q(S)$ then \\
\nudge $\err \gets\err +1$\\
Return~$(a,\err )$\\\\
%
\oracle{$\HashOracle(x)$}\\
for $i=1$ to $k$\\
\nudge $h_i(x) = \rho_1(x)+i \cdot \rho_2(x) \bmod m$\\
Ret $\left(h_1(x),\ldots,h_k(x)\right)$
}
{
\underline{{$\game{3}(A)$},\fbox{$\game{4}(A)$}}\\
$c\gets 0$, $\bad \gets \false$, $\err \gets 0$\\
$\mathcal{I}\getsr [\{1,2,\ldots,q\}]^r$\\
$S \getsr \distr{\calS}{}$\\
$(M,\pubaux,\privaux) \getsr \Rep^{\HashOracle}(S)$\\
$z \getsr A^{\TestOracle}(S,\pubaux)$\\
if $\bad = \true$ then \fbox{Return 0}\\
if $\err  < r$ then Return 0\\
Return 1\\
%
\oracle{$\TestOracle(q)$}\\
$c \gets c+1$\\
$v \gets \Qry^{\HashOracle}(M,\privaux,q)$\\
if $c \in \mathcal{I}$ and $v = q(S)$ then \\
\nudge $\bad \gets \true$ \\
if $c \not\in \mathcal{I}$ and $v \neq q(S)$ then \\
\nudge $\bad \gets \true$\\
if $v \neq q(S)$\\
\nudge $\err \gets\err +1$\\
Return~$(v,\err )$\\
%
\oracle{$\HashOracle(x)$}\\
$a,b \getsr [m]$\\
for $i = 1$ to~$k$\\
\nudge $v_i = a+i \cdot b \bmod m$\\
Ret $\left(v_1,\ldots,v_k\right)$
}
}
\caption{\Cref{thm1}:Game playing argument}\label{fig:Game}
\end{figure}


%\caption{PRF game}\label{fig:prf}
\begin{figure}
\centering
\fpage{0.45}{
\hpagess{0.4}{0.35}
{
$\experimentv{\ExpPRF{F}{B}}$\\
$K \getsr \calK $\\
$\rho \getsr \Func{\univ,[m]}$\\
$b \getsr \bits$\\
$b' \getsr B^\calO$\\
Ret $[b = b']$\\
}
{
$\oracle{\calO \smallskip(x)}$\\
if $ b = 1$ then\\
\nudge Ret $F_K(x)$\\
Ret $\rho(x)$\\
}
}
\caption{PRF security notion}\label{fig:prf}
\end{figure}

%\caption{Non-adaptive adversary $D$ simulating $\game{4}(A)$} \label{fig:D}
\begin{figure}
\centering
\fpage{0.35}
{
$\adversaryv{D(S)}$\\[4pt]
$c \gets 0$\\%, $\calX \gets \emptyset$\\
$\err \gets 0$\\
$\mathcal{I}\getsr [\{1,2,\ldots,q\}]^r$\\
Run $A(S)$\\
When $A$ asks $\Test(x)$:\\
\nudge $c \gets c+1$\\
\nudge $r \gets 0$\\
\nudge if $c \in \mathcal{I}$\\
%\nudge \nudge $\calX \gets \calX \cup \{x\}$\\
\nudge \nudge $r \gets 1$\\
\nudge \nudge $\err \gets \err + 1$\\
\nudge Ret $(r,\err )$\\
When $A$ halts:\\
\nudge Ret 1
}
\caption{Non-adaptive adversary $D$} \label{fig:D}
\end{figure}	

\end{proof}

